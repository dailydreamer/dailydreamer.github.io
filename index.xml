<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome to Dailydreamer&#39;s Space on dailydreamer</title>
    <link>https://dailydreamer.me/</link>
    <description>Recent content in Welcome to Dailydreamer&#39;s Space on dailydreamer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 24 Oct 2021 00:19:53 +0800</lastBuildDate><atom:link href="https://dailydreamer.me/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>探秘意识 - 读《我是谁或什么》</title>
      <link>https://dailydreamer.me/posts/2021-10-24-the-minds-i/</link>
      <pubDate>Sun, 24 Oct 2021 00:19:53 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2021-10-24-the-minds-i/</guid>
      <description>《我是谁或什么》是认知科学学者、美国文理科学院院士侯世达编辑的一本科幻短篇小说集。里面的多篇小文章从不同的侧面对“意识”这一神秘话题进行探讨。我试图通过斑驳的拼图拼凑出一副完整的图景，通过整理对意识的理解，从中一窥自由意志的真谛。更重要的是，对意识更充分的理解，可以为我们妄图创造真正智能的尝试打下基础。
意识是什么 - 从概念到科学 意识，作为一种概念一直难以被精确定义。不同于其它物理现象，意识存在着罕见的不对等性：意识者本人作为一位受到偏爱、享有特权的观察者，他观察这一现象的途径与其他所有人都完全不同，而且远胜于其他人，无论他人拥有什么样的仪器。基于这种不对等性，衍生出了不同的视角。例如对于“我”这一客体的观察，就存在各种不同的视角：我眼中的我、他人眼中的我、我想象他人眼中的我、他人想象我眼中的我，等等彼此各不相同。由于这种“不对等性”，过去对于意识的科学研究一直处于模糊不清的状态。
随着近代物理中相对论和量子力学的发现，意识“意外地”成为了科学研究中不可或缺的一部分。相对论描述了，处于相对运动的不同系统中的观察者感知到的世界并不一样；而在量子力学中，观测结果的描述需要考虑观测者的观测这一事实本身。因此，观测者也参与了物理现实的建立。科学家失去了旁观者的角色，成为所研究系统的主动参与者。物理事件也因此与观测者意识不可分割了。
随着近代物理学、生物学和心理学的研究逐渐深入，对于意识有了如下的认识：
 首先，意识可以用中枢神经系统的活动来解释，神经活动又可以还原为生理系统的生物结构和功能 其次，所有层级的生物学现象都能完全通过原子物理学，即通过组成生物的碳、氮、氧等原子的运动和相互作用来理解 最后，要研究原子物理学，现在对其最充分的理解方式来自量子力学，而量子力学又把观测者的意识作为系统的重要部分  至此，目前对意识的研究从模糊的概念走向了科学，但似乎陷入了一种发乎心、止乎心的奇妙循环。
意识的判定 - 从现象上观察 要真正理解意识是什么，就需要研究清楚意识是如何判定的。对意识的研究最早是从现象上开始。我们常常推己及人的认为他人也同样有意识，那么对于一个动物或者一个机器人，我们如何判断他们是否有意识呢？
因为意识的不对等性，对于意识并没有可靠的探测手段。另一方面，我们相信他人有意识其实是基于对他人的外部观察。那么对于意识的判定，就可以使用基于观察或问询的方法。
至于观察和问询的内容，就要考虑到：意识的本质是一种思维活动，重要的是思考的模式。可以从如下几个方面进行考量：
 首先，能够能够区分主体和客体，即认识到自我的存在。 其次，能够进行自省性报告，即汇报自己内部的状态。 最重要的是，能够形成类别的抽象概念，学习到不同类别的表征。特别的是，能够学习到关于自我的表征，即能够认识不同视角下的自我这个类别。  举个栗子。婴儿刚一出生没有自我的意识，通过不断从观察中学习，慢慢的能够区分自己和其他的世界，能够向妈妈哭出自己饿了，直到18个月左右才能渐渐认出镜子中的自己。这时候，我们可以认为这个婴儿有了完整的意识。
这些判定条件是如何得出的，就要从对意识涌现的观察谈起。
意识的涌现 在复杂性科学领域中，“涌现”是指复杂系统在从微观到宏观自组织过程中，新结构、新属性的突破性出现。人作为我们最熟悉又最陌生的复杂系统，意识一直是其中最神秘的部分。自底向上看从生理的角度看，我们的脑在低级神经生理层次上的各种动作，其本身没有对意识的感知，却从中涌现出了高级符号层次才能理解的意识。每一个神经元时空上的局部发放，层层组合成了长期目标、理想、兴趣、口味、希望、道德等全局表征，最终组合而成了人对自我的表征。
意识究竟是如何涌现的，自底向上我们还未研究透彻。但是可以自顶向下从进化的意图去理解，为了能够在这个快速变化的世界迅速反应并作出更优的决策，人类进化出了脑。除了根据当前的情况直接反应，为了预测未来以进行更好的决策，模拟的能力也进化了出来。而主观意识则是模拟能力演化的顶峰：当模拟足够复杂的时候，模拟中就必须要包括自我的表征。这种自我表征的能力最终促成了意识的诞生。同时为了更快地更新表征以适应不断变化的环境，人类还进化出了学习的能力。这使得人类在后天还可以从环境中不断更新这种表征，从而形成独特的意识。这样看来，意识的涌现是优胜劣汰进化的必然。
这里还存在一个有趣的问题，我模拟出了自我的表征模型，那么这个自我的模型是否也需要模拟出一个自我的模型呢？我想为了更好的预测这个世界，答案应该是肯定的，正如高手都会预判你的预判的预判的。。。为了更好的预测世界，“意识”会给世界建模（表征），也会给处在世界中的自己建模（自我表征）。然而，建模中的自己也具有不断变化的意识，因此，“意识”建模时也需要对自己的意识建模。不过出于实际计算量的考虑，这种包含无穷自指的模拟会在某一层停止，取得一个效率和性能的平衡。这种无穷的自指，就像你前后有两面对立的镜子，那么一眼望去镜子中的你也看着镜子中的你也看着镜子中的你。。。层层递进。
“我是我身体里的一场梦” - 关于自由意志 当我们认识到意识是在神经系统的发放中涌现的，而这种发放是受到决定性的物理法则约束的。那么我们不禁会怀疑，人是否有自由意志呢？
在牛顿力学的时代，物理法则和结果都是决定性的。虽然量子力学的发现带来了概率描述的结果，不过这并不影响物理法则的决定性，这种结果的概率分布中也并没有留下自由意志影响的余地。所以在世界的角度看，如果有一位全知的造物主的话，他会残酷地掷骰子，摆弄着不存在自由意志的我们。
然而巧妙的是，意识是一个如此不对等的现象，即使是造物主也不能妨碍我们意识到自己是有自由意志的。模拟出一个带有自由意志的自我模型，对人类的生存、繁衍、发展，对我们合理化的行动，都是有着积极的意义的。只有意识到自己的主观能动性，意识到美好的生活可以通过努力奋斗得到，我们才会对当下所得感到满足，对明天所期充满希望，即使我可能只是我身体里的一场梦。
所以真正重要的是，我们是否感到有自由意志。人本无自由意志，正如人生本无意义。是我们不懈地追求，最终赋予这段旅程以意义。哪怕这个残酷的世界糟糕透顶，只要继续踏上旅程，就能感受到街边飘来的花香，午后温暖的阳光，这些小小的幸福的断片；当然也会有面对未知的恐惧，脸上划过的泪水，这些更加丰满的体验。旅途本身就是奖励，而这正是我们的自由意志，是我们无悔的选择。</description>
    </item>
    
    <item>
      <title>Python 并发模型</title>
      <link>https://dailydreamer.me/posts/2018-11-25-python-concurrency/</link>
      <pubDate>Sun, 25 Nov 2018 17:43:19 -0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2018-11-25-python-concurrency/</guid>
      <description>同步的I/O操作会白白消耗很多时钟周期，因此许多编程语言都提供了并发模型来实现异步I/O。今天简单介绍一下Python中的并发模型。
开始之前先澄清一下并发和并行的关系。并发（Concurrency）是指一次处理很多事情，而并行（Parallelism）是指同时做很多事情。并发是处理问题的一种方式，而并行则必须由硬件支持。
Multi-thread 多线程是最传统的并发模型之一，线程之间通过共享内存来通信，通过互斥锁来防止对临界区域同时读写。
曾经以为由于CPython在实现上采用了GIL（Global Interpreter Lock）来保证线程安全，导致其多线程模型基本不可用。后来了解到Python标准库里所有阻塞I/O函数都会释放GIL，自己编写的函数也可以通过C扩展来释放GIL。所以Python多线程模型在I/O密集型程序中是完全可用的。对于计算密集型程序，可以使用有类似接口的多进程模型处理。
但是多线程模型有一些缺点：
 一个线程可能在任何时候被打断，需要上锁，导致很难理解 线程的存储和切换负担相对协程还是较重  为了解决这些问题，Python 3.4引入了asyncio的协程模型。
asyncio Python的asyncio使用轻量级的协程作为调度单位，因此可以达到更高并发。同时协程运行过程中天然被保护，必须显示交出控制权（yeild）给其它协程运行，否则不会被打断。
Python的asyncio非常类似于Node.js的Event loop + Async/Await。 Node.js曾尝试使用回调函数并发模型，但是最后因为回调地狱走向了Async/Await。相比于回调，Async/Await还解决了回调context丢失，不好错误处理的问题。
但是asyncio给Python带来了新的问题：生态的分裂。协程链最后会被asyncio的API驱动，比如loop.run_until_compelte()；而协程链最开始总是被异步I/O API发起，比如asyncio.sleep()或aiohttp.request()。因此要使用asyncio框架，则需要生态中的所有部分如Web框架、数据库驱动、消息队列、各种客户端等全部用协程重写。目前来看Python的asyncio生态还是不够成熟。
Go Model 当然，其它语言也有着很多不同类型的并发模型。写到这里不得不提一下Golang，作为近些年来热度不断上升的语言，它的并发模型有其独到之处。
Golang实现了CSP（communicating sequential processes) Model。它使用轻量级协程和runtime中的调度器来实现并发，即使其I/O函数是同步的。当一个goroutine阻塞时，runtime调度器会自动切换到其它goroutine，这有点类似于轻量级的多线程模型。不同于多线程模型的是goroutines之间通过channel传递信息通信，而非共享内存，这样来保证同一时间只有一个goroutine访问一个临界区域。正如Rob所说，“Do not communicate by sharing memory; instead, share memory by communicating.”
虽然Golang也存在其它问题，尤其是跟Erlang实现的Actor Model对比时，但是它的成功是显而易见的。
结语 本文回顾了Python中不同的并发模型，简略提到了Golang中的并发模型。从来没有一个最好的语言和并发模型，只有最适合的。虽然Golang的高性能和高并发很吸引人，Python的优雅、灵活、快速开发则是其长盛不衰的原因。</description>
    </item>
    
    <item>
      <title>历史的教训</title>
      <link>https://dailydreamer.me/posts/2018-11-20-lessons-of-history/</link>
      <pubDate>Tue, 20 Nov 2018 07:33:02 -0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2018-11-20-lessons-of-history/</guid>
      <description>前段时间趁Kindle打折入手了几本小书，其中包括了杜兰特夫妇所著《历史的教训》。杜兰特夫妇花费50年精力著有1500万字的《世界文明史》，而这本《历史的教训》可以看作是其看尽世界文明背后的思考与智慧。“人类历史只是宇宙中的一瞬间，而历史的第一个教训就是要学会谦逊。”开篇就将我们从平日的纷纷扰扰中拉出，那就让我们怀有敬畏之心，跟着作者去一探历史带来的思考。
自由与平等 身在其中，可能很难对自己所处的社会有客观的思考；观察整个生物的历史，则可能提供一些有益的思考。
生物学给历史的第一个教训就是，生命即是竞争。当食物丰盛时竞争是和平的，当粮食紧缺时竞争是充满暴力的。类比到国家，资源丰富时觅食是和平的竞争，而极端情况下就是战争。
生物学给历史的第二个教训是，生命即是选择。物竞天择适者生存是自然界教会我们最残酷的真实，不平等是生命的自然和常态。在这种固有的不平等中，我们所追求自由和平等永远保持着微妙的动态平衡，此消彼长。19世纪自由主义统治下的英美在市场经济“看不见的手”调节下，经济飞速增长，不平等和垄断也随之滋生，最后以凯恩斯学派实施经济调节政策，对“自由”的背弃而告终。
只有经济处于平均水平以下的人才会渴求一味的“平等”，才智高超的人向往自由，而最终的结果总是后者得偿所愿。因此财富集中是自然而不可避免的。但是可以借助暴力或是和平的部分再分配而得到周期性的缓解。“所有的经济史都是这个社会有机体缓慢的心脏跳动，财富的集中和强制再分配，便是它巨大的收缩与扩张运动。”而权力也和财富一样，不可避免的收拢然后被再分配。
国家们也在自由和平等这一连续谱上不断的调节着。对资本主义的恐惧，迫使社会主义不断扩大自由；而对社会主义的恐惧，则迫使资本主义不断增加平等。人人不可能生来平等，但教育和机会平等也许是一个比较好的平衡点。
战争与和平 在过去有历史记录的3421年中，只有268年没有发生过战争。可以说，和平只是一种不稳定的平衡，只能靠公认的霸权或势力均衡来维持。
国家也是由人来统治，它继承了人的贪婪、争强好胜、骄傲，以及对食物、土地、资源、燃料与霸主地位的欲望，但是却缺少道德、法律的约束。联合国抱持着这样的理想，却从来没有能力去实施。却是核力量作为一种霸权，对过激的战争行为产生了约束。
因此作者以为，人类的本性并没有发生实质性的改变，所有的技术成就，都不得不被看成是用新方法完成旧目标——取得财货，追求异性（或者同性），在竞争中取胜，发动战争。
结语 尽管如此，我还是认为在这种螺旋上升的过程中，能够从微观上体验并享受人生的美好就是普通人的幸福。而历史则是这一切的记录者与见证者，默默的推动着人类的进步。正如作者所言，历史是一座英灵的城市，一个广阔的思想国度，那儿有无数的圣哲贤明、政治家、发明家、科学家、诗人、艺术家、音乐家、有共同爱好的人以及哲学家，他们谈笑风生，有说有笑，有跳有唱，有雕有刻。</description>
    </item>
    
    <item>
      <title>穷查理宝典</title>
      <link>https://dailydreamer.me/posts/2018-07-13-poor-charlie/</link>
      <pubDate>Fri, 13 Jul 2018 22:34:47 -0700</pubDate>
      
      <guid>https://dailydreamer.me/posts/2018-07-13-poor-charlie/</guid>
      <description>看完Ray Dalio的《原则》之后，对大佬们的思维方式产生了极大的兴趣。《穷查理宝典》是另一本备受推崇的大佬传记。查理·芒格是巴菲特倚重的合伙人，低调但是个性十足。
查理最为推崇的便是心理学和多元思维模型。心理学是理解人在市场中的行为的重要理论依据，而多元思维模型则提供了这样的框架。相比Ray含蓄的在企业中使用心理学的成果，查理更是直接的推崇心理学的重要性，他的多元思维模型就是以心理学为基础建立起来的。
但是这也导致他对现在心理学学院派的不满，认为他们太多的局限在自己的体系和小领域里，而对心理学在现实世界的应用缺乏关心，很少提供人们面对现实问题时的思维框架（和心理系的陆博士聊了聊，其实这样的问题确实存在。我和陆妹妹也在酝酿一个能落地的心理学的idea，敬请大家期待）。不光是心理学，查理对其他的学科也有同样的抱怨，认为他们过度的自闭导致了“铁锤人综合证”，手里有锤子看见什么都想砸一下。所以查理才提倡跨学科思考，并提出了自己的多元思维模型。如果只拥有少量的思维模型，那么心理学研究表明，人们会扭曲现实直到它满足你的模型（也就是machine learning的欠拟合哈哈）。 理查德·费曼也曾说过：“首要的原则是你必须别欺骗自己，因为自己是最好骗的人”。
多元思维模型其实就是一个检查清单，从不同学科的角度来理解一个复杂的现实问题，然后综合考虑。下面讲讲对查理提到的几个思维模型的理解和自己的一些感悟。
逆向思考 这是印象最深的一个模型了，虽然很早之前就在数学里经常用到反证法，但是经查理提起后才发现最近经常遇到这种思维方式。查理说，要想成功，先知道怎么失败，然后避免它，Ray也说过类似的话。学画画临摹的时候，老师会讲不要看填充的地方，而要看着空白处的形状。项目管理课上，老师讲要项目成功，先知道有哪些风险。某服装品牌CIO说过，要了解一个行业，先知道这行的公司是怎么死的。David Patterson给过一个talk，How to Have a Bad Career。阿兰·德波顿曾写道，“我一开始写作，缺乏一个明确的定位，我只知道我不可能成为哪类作家”。这个世界的本质是不对称的，试着从反向思考问题，往往会有奇效。
双轨分析 查理会时常同时使用直觉和理性分析一个问题。直觉是大脑在潜意识状态下快速的分析过程，它能囊括更多的数据，但是模型可能只是过去自己理性分析模型的内化和长期基因进化的沉淀，且常常因为情绪等因素失灵；而理性没法像直觉那样快速处理大量数据，但是模型更加鲁棒。结合这两种分析，更容易得到更好的结果。
关于分散还是聚焦 Ray之前说过，“想要拥有很多优势，而又不暴露于不可接受的劣势之下，最稳妥的方式是做出一系列良好的、互不相关的押注，彼此平衡，相互补充”。而查理不同，他认为“聪明人在发现这样的机会之后会狠狠地下注。他们碰到好机会就下重注，其他时间则按兵不动。就是这么简单”。我的理解是应该聚焦，但是不能过度聚焦。准备好备份方案，对于可能出现的风险要控制到自己能接受的程度。
其他思维模型 概率分析 目前我们对于世界的有效理论还是基于概率的模型，因此在理性分析的时候，使用概率模型能够提供更加准确的判断。
断裂点理论 量变引起质变，沉淀到一定程度后会突然爆发，就如压力在不停的累积到一定程度后大桥会一下断裂。
复利思维 $$ 1.01^{365} = 37.8 $$ $$ 0.99^{365} = 0.03 $$
$$ 1.02^{365} = 1377.4 $$ $$ 0.98^{365} = 0.0006 $$
坚持不懈的小小积累也能有巨大威力。
结语 细心留意就会发现，大佬们虽然成功的套路各不相同，但是meta learning的方法确有共同之处。有时他们会分别用不同的语言体系，讲出同样的事情。能够看到这些才是开始，能够践行并且坚持可能才是最重要也最困难的吧。</description>
    </item>
    
    <item>
      <title>原则</title>
      <link>https://dailydreamer.me/posts/2018-06-13-principles/</link>
      <pubDate>Wed, 13 Jun 2018 17:19:22 -0700</pubDate>
      
      <guid>https://dailydreamer.me/posts/2018-06-13-principles/</guid>
      <description>前些时候无意间看到了瑞·达利欧关于原则的一系列短片，被其深情而不失沉稳的娓娓道来所吸引，于是找来原书翻看，结束Kindle的长期吃灰。很多人可能觉得这只是一部说出了许多人人都懂却做不到事情的鸡汤，不过如果能有一些共鸣，一些思考，一些小惊喜，这点喜悦对我来说就足够了。下面讲几点我的小感悟。
总结自己的原则 原则就是一系列决策所需考虑的要素。
Ray认为，应该将自己的原则总结出来，然后按照这些原则来决策。这样有几点好处：
 避免有害情绪的影响 便于改进自己的原则 甚至可以将原则转化为算法，使用系统化的方法决策  Ray关于有害的情绪是决策最大威胁这点其实我是心存疑问的。诚然有时情绪会对决策产生负面影响，如愤怒时的短视行为，但有时情绪能激发出力量，如爱可以让人坚忍。“有害”情绪很难从别的情绪中区分出来。Ray仿佛想让自己的决策是绝对理性思考的结果，避免一切情绪的干扰，而这样的话人和机器人又有什么区别呢？
Ray会从两种不同的渠道改进自己的原则，一个是与其他智者交流自己的原则，询问他们的意见；另一个则是通过自己的失败去学习，这点之后会讨论。
将原则转换为算法是Ray近年努力的目标，以确保在他离开时桥水还能拥有他的智慧。
很多大佬其实都发表过类似的观点，Elon Musk 说过将自己的大脑看成计算机算法，David Silver (Lead researcher of AlphaGo) 也曾说人生就是一个巨大的 training set。
关于失败的态度 Ray认为成功的关键在于，既知道如何努力追求很多东西，也知道如何正确的失败。正确的失败即既能从失败中学到教训，又不至于被踢出局。
痛苦 + 反思 = 进步
失败是痛苦的，但是Ray把痛苦视为大自然的提醒，以一种截然不同的方式体会痛苦的过程，在痛苦中思索它的教益。这样想来，有时也竟不觉的痛苦了。当成习惯之后，甚至可以步入新的境界：
 找到，接受，并学会如何应对你的弱点 更喜欢周围的人对你坦诚，而不是隐瞒对你的负面看法 展现真实的自我，而不是强行把弱点伪装成优势  这个视角让我想起了正念。陆妹妹常常给我安利正念的神奇，这种对当下情绪的觉察和保持不亲不疏的关系，也许正是进步的开始。
工作原则 Ray给组织设立的原则，其决策规则是创意择优：
 坦陈自己最诚实的想法 理性地表达分歧 用创意择优来处理所有不同意见（例如可信度加权决策）  为了让创意择优发挥作用，Ray需要对组织里的每个人的不同个性有所了解。个性没有好坏，只是不同，而组织里不同的任务需要不同个性的人合作完成。就像你不会安排一个在防守方面表现得很好但打击率仅为0.160的外野手作为第三棒出场一样，你也不会安排一个拥有宏观思维的人去做需要关注细节的工作。
Ray通过一系列的心理测评，给每个员工制作公开的“个性棒球卡”。这种方式初听有些难以接受，但是只要认同个性没有好坏只是不同，并且慢慢适应之后，棒球卡就会带来诸多的好处。
成功人士的共性 Ray总结了许多成功人士的经历，说了如下一段话：
他们都是独立的思考者，不会让任何东西或任何人妨碍自己追求大胆的目标。对于事情应该怎么做，他们在头脑里有十分坚定的规划，同时又始终愿意在现实中检验这些头脑规划、调整做法，从而使规划效果变得更好。他们都极为坚韧，因为相对于他们在追求梦想的过程中经历的痛苦而言，他们实现梦想的决心更强烈。也许最有意思的是，他们关于未来的视野要比多数人宽广，或者他们自己就有这样的视野，或者他们善于从能看到更多东西的人那里学习。他们都能同时看到大图景和小细节（以及中间的层次），并能综合在不同层次上总结的观点，而大多数人通常是见此不见彼。创造性、系统性、现实性在他们身上合而为一。他们既是坚决的又是开明的。最重要的是，他们对自己的事业充满热情，对表现一般的手下不能容忍，同时想给世界带来巨大、有益的影响。
对于目标的看法 Ray一语道破本质：“把赚钱作为你的目标是没有意义的，因为金钱并没有固有的价值，金钱的价值来自它能买到的东西，但金钱并不能买到一切。更聪明的做法是，先确定你真正想要什么，你真正的目标是什么，然后想想你为了得到这些目标需要做什么”。很多人将赚钱作为自己的小目标其实是缺少对于自己的觉察，亦或是懒得去思考自己真正在乎的是什么，就随波逐流的将赚钱作为自己的目标。诚然这是非常稳妥的一种方式，但是不面对自己本心，跟提线的木偶又有什么区别呢？
那么人们真正想要的是什么呢？Ray有一个观察：“一个东西要好，就必须符合现实的规律，并促进整体的进化，这能带来最大的回报。这种持续地追求学习和改进的动力，让人类天生地对进步感到快乐，对快速进步感到兴奋。尽管大多数人觉得他们是在追求能让自己快乐的东西（玩具、大房子、金钱、地位等），但这些只能带来小的满足，远远无法与进步能给大多数人带去的长期的满足感相比”。Ray试图从进化的角度去解释人们对价值感的追求，也是一个新颖的看法。
结语 以上就是我的一点感悟。Ray因为儿子曾患双相人格障碍而接触心理学，在这些原则中心理学的影子无处不在。相信能够把系统化的心理学运用在实际企业管理中去，也将是一个机遇吧。</description>
    </item>
    
    <item>
      <title>智慧服装</title>
      <link>https://dailydreamer.me/posts/2018-06-13-apparel-sales-prediction/</link>
      <pubDate>Wed, 13 Jun 2018 00:30:35 -0700</pubDate>
      
      <guid>https://dailydreamer.me/posts/2018-06-13-apparel-sales-prediction/</guid>
      <description>在GIX的第二年，在探索中思考，在痛苦中学习，一个重要的收获之一就是有了自己的第一个愿景：用新技术给传统行业赋能。技术是我的热爱，而接触不同的行业又能极大的满足我对世界的好奇，同时国内的很多传统行业正处在数字化智能化转型的生死快跑中。今天来讲讲服装行业的机会。
现在直销服装品牌的一件服装的生命周期为：设计 -&amp;gt; 计划 -&amp;gt; 采购 -&amp;gt; 生产 -&amp;gt; 物流 -&amp;gt; 销售 -&amp;gt; 客户。跟一切买来东西加工后卖出去的生意（比如零售、投资等等）一样，对需求的预测是一切后续行动（配货、调货、补货等）的核心。需求预测的过少，会损失潜在的销售机会；预测过多，会导致库存积压，严重甚至会资金链断裂。
预测可以分为三个维度：场（总盘，区域，店），时间（年，季度，周），商品（总盘，大类，SKU）。不同维度的预测能辅助不同程度的决策（如年度财务规划，季度商品计划，销售时的调拨补货计划等）。
我们走访了几个自营品牌，现在基本是靠店长来手动做这些计划。通过POS机和ERP系统的销量、库存信息，总结出一些规则如畅销滞销款、库销比等等，结合店长自身的经验做出决策，之后复盘帮助店长成长。
算法驱动的预测相比传统手工预测有如下几个好处：
 准确性可靠性高。人类就像莫比乌斯环上的蚂蚁，在螺旋中不断前行。纵观历史的长河，很多事情都是一再重复的发生，而人类局限于自己的尺度，很多时候并不能对事物发展的趋势进行很好的判断。在面对大量的数据时，甚至不可能在有效时间内做出判断。同时，人很难避免情绪的影响，而情绪会极大程度影响判断。 可复制性强。手工预测依赖店长的个人能力，会随着店长的流失被带走；而且店长时间有限，很难兼顾全部商品。 可持续改进。算法可以根据数据反馈持续改进，将店长的智慧永存。  同时算法驱动的预测也有其局限性（比如很难进行涉及潮流趋势的商品计划），因此实际执行时，我们会按由易到难的顺序慢慢改进，先预测现货服装，再预测期货服装销量。
后续工作可以有根据预测的销量规划调拨补货的行动，基于视觉的服装自动打标，联动到生产的智能工厂，联动到销售的智能店铺等，我们做过一些初期的探索，有很大的想象空间。</description>
    </item>
    
    <item>
      <title>XLChain</title>
      <link>https://dailydreamer.me/posts/2018-06-03-xlchain/</link>
      <pubDate>Sun, 03 Jun 2018 22:00:00 -0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2018-06-03-xlchain/</guid>
      <description>Overview This is a course project of our Fabrication and Physical Prototyping course, implemented by Xincheng Li and Chengxi Xia. Blockchain is a hot topic recently, but only very few people know the theory behind it. This project want to introduce the simple mechanism of blockchain leveraging the tangible object interaction, under the constraint of the course requirement.
XLCahin
We&amp;rsquo;ve already seen some interesting visualization about blockchain, like ethviewer, etc. Though it is inspiring to see these digital visualization, tangible visualization would be more fun to play with, thus easy to accept by broader range of people, especially young children.</description>
    </item>
    
    <item>
      <title>FoodGo, 层级式的配送小车</title>
      <link>https://dailydreamer.me/posts/2018-01-28-foodgo-autonomous-food-delivery/</link>
      <pubDate>Sun, 28 Jan 2018 22:34:59 -0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2018-01-28-foodgo-autonomous-food-delivery/</guid>
      <description>FoodGo是之前参加2017年GIX创新大赛美团点评组的项目，当时拿到了一等奖。 人力成本越来越高的今天，低工资的配送员的数量不能满足快速增长的外卖市场的需求，等待时间的加长严重影响了用户体验。 使用机器人来辅助配送成为一种可能。 FoodGo的创新点在于使用层级式的方式配送。 大车带着小车在大路上跑，在系统规划的地点放下小车，小车自动驾驶到用户指定的送餐地点等待用户，而大车可以直接开往下个地点。 这样一来占送一批单很大时间的末端配送和等待用户这一工作可以交给机器人来完成，成倍提升了运力。 而且这一方式以后可以升级为大车也无人驾驶，渐进式的方案更容易快速落地。 可以参考下面这个视频
今天主要来讲讲实现原型时的一些技术问题。
框架 为了快速迭代原型基于ROS和turtlebot kobuki进行实现。主要框架如图下所示
主要有四部分，sensor数据的处理，rtabmap SLAM框架，path planner以及controller。 Sensor使用了ZED的双目摄像头。选用双目是因为RGBD摄像头在室外环境无法使用，而Lidar价格过于昂贵。 选用ZED是因为虽然它基线较短在室外场景远距离精度有限，但是它便宜并且有完善的驱动，虽然最后被驱动坑了很多。。。下文会提到。 SLAM框架选择了rtabmap因为它在ROS上提供了完整的建图定位工具链，适合快速开发原型。 Path planner和controller直接选用ROS提供的move_base，它使用了dijkstra算法作为global planner，DWA算法作为local planner。
传感器及处理 这部分本来的理想情况是使用ZED的驱动直接获取深度信息，但是问题来了，ZED的驱动必须要cuda库，而我的笔记本没有GPU。。。 所以这部分只能利用ROS的一些库自己实现了。 ZED摄像头在Ubuntu 16.04下能被系统驱动识别显示为 /dev/video* (*的数值取决于你的其他video设备)，而在Ubuntu 14.04的驱动下还无法识别，当时为了这个还重装了系统。。。 然后我fork了一个开源的ZED CPU驱动，做了一些小修改。 它使用OpenCV的ROS bridge将图片读入ROS，将它们发布成左右两个ROS topic并作时间同步。 然后使用ROS的stereo_image_proc包undistorting原始图像并且算出disparity map。
一开始我使用了ZED出厂的校准参数，结果stereo image proc报错opencv assert failed。 后来使用ROS的camera calibration包重新校准了一下就没有问题了。
有时候CPU的计算能力不足以使用stereo image proc将每帧图像都实时undistorting，就会出现发布的undistorting后的左右图片丢帧，这时候rtabmap有一个参数approx sync可以大致对齐stereo camera的时间戳。
当时还遇到了一个问题，就是robot坐标系base link到摄像头坐标系camera link是一个平移，但是摄像头坐标系到实际的图像坐标系是有一个别扭的旋转的，因为它们安排x y z轴的指向并不一样。 当时忽略了这一点导致建出来的图是旋转的，困扰了一阵子。 具体如何旋转可以参考这个回答。
Rtabmap建图与定位 由于没有使用额外的地图API，需要自己建图来导航。 ROS的move base接受grid map，一般的SLAM算法实现中没有集成生成grid map的方法，这也是选择rtabmap的一个重要原因。 建图建好之后存进一个sqlite数据库中，rtabmap从数据库中读取grid map并发布出来，通过处理ZED摄像头的双目图像，发布机器人的tf。 同时rtabmap还有point cloud xyz模块可以过滤从ZED生成的点云数据，找到地平面然后聚类地平面以上的障碍物。有了tf，grid map和障碍物点云数据，就可以使用ROS的move base进行导航和避障了。
总结 一个简单的使用双目摄像头的导航避障小车就实现完成了。 使用双目对障碍物的检测有时会存在误报的情况，可以成为一个可改善的方向。</description>
    </item>
    
    <item>
      <title>过去失败的创业尝试</title>
      <link>https://dailydreamer.me/posts/2018-01-09-past-failed-experiences/</link>
      <pubDate>Tue, 09 Jan 2018 22:52:10 -0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2018-01-09-past-failed-experiences/</guid>
      <description>07/19/2018 Update：这半年自己也成长了不少，今天回过头来看这篇文章，发现自己忽略了很重要的一个失败因素：有效的团队。之前大家更像是一个group，虽然在一起玩的很开心，但是并没有真正花时间去build effective team。group和team的差异在于team在行动之前，会花时间建立大家都认同的价值观和行为准则，并形成team charter指导日后的工作。我个人非常在乎的原则是绝对透明，这意味着及时而坦诚的沟通自己的想法和顾虑，想想看来在之前的团队其实这点做的并不是很好。认识到这点后我在新团队尝试实践这个原则，取得了很好的效果。
 2018年到了，很多人都在朋友圈里发年终总结，我也整理了一下过去的照片，回忆起了本科的时候曾经有两次试图创业的经历。 虽然都无疾而终，但是现在想起还是有很多美好的回忆，以及接下来要跟大家分享的经验教训。
Nutt Nutt 坚果健身是一个能收集器械健身数据的智能硬件。
当时是第一次参加创客比赛，抱着试一试的心态，但是因为优秀的团队合作和切中热点的题目，我们最后获得了2015年中美青年创客大赛的一等奖（这里也可以看见选择的重要性哈哈）。 这个比赛的级别很高，比赛之后接受了一些媒体采访宣传，还有机会去了湖南卫视的天天向上，也是第一次接触到了一些投资人，同时有一个硬件工厂想要和我们合作把这个项目落地。 在这一片喝彩的声中，我们就决定试一试。 现在想起其实缺少很多冷静的分析和思考。
其中细节按下不表。几点经验教训：
 中途受邀请准备很多展览、接待领导人参观，我们都没有拒绝。表面看起来风光，其实浪费了很多时间，而且大部分活动并没有带来任何的宣传效果，做的是无用功。 在过了最初的新鲜感之后，由于学业上的压力，以及合作方的不给力，团队的工作进度开始慢了下来，到最后的接近停滞。这期间团队之间没有像比赛那时侯一致的目标，但是并没有相互沟通清楚自己的期待和动机，导致了大家工作热情低下没有动力。  虽然最后项目没有做成，但是这也是我第一次接触设计思维的方法论，从此就在这条道路上探索了下去。
Pootoo Pootoo是从我们实际的学习生活中来的。 大学中的学生辅导员工作中的很大时间都是用作一些低效率的反复通知和收发文件，当时想到如果能有一个App来帮他们做通知送达，文件自动收集规整，以及进一步可以是一个大学生知识分享平台就好了。
细节还是有机会再说，经验教训：
 辅导员的效率工具对于辅导员还有学生来说都是一个使用频次比较低的东西，大概在一周一到两次，想要从这里切入做成知识分享平台有难度。 辅导员和大学生并没有很强的付费倾向，现在的这种方式对他们来说也可以接受，说明这是一个痒点并不是痛点。 在2016年，移动流量红利基本已经过去，这种类型的App想要融资难度比较大。 技术选型的时候，太执着于当前最新“最好”的技术，而没有考虑到团队的熟悉程度和学习成本，没有根据商业需求来技术选型，导致最后开发周期过长。  可以说这次尝试创业让我更加了解了现实世界的运行规则，技术和产品并不是一切。 虽然作为一个创业者可以对技术和产品有自己的坚持，但是作为公司来讲这些都只是为商业在服务，如何做好这其中的权衡是需要慢慢体会的。
结语 Learn from fail. 这次记录下来之前项目的经验教训，是为了以后自己不会再犯同样的错误。嗯，黄金圣斗士不会被同样的招式打败第二次。</description>
    </item>
    
    <item>
      <title>Nutriment</title>
      <link>https://dailydreamer.me/posts/2017-12-05-nutriment/</link>
      <pubDate>Tue, 05 Dec 2017 02:25:44 -0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2017-12-05-nutriment/</guid>
      <description>Introduction Nutriment is a project that I developed with Ibtasam and Jay for MSTI Design Thinking Studio. We started from idea brainstorming and secondary research, we did primary research to refine our design question and to come up with design requirements, then user scenarios and core tasks were generated, finally we made a low fidelity prototype and conducted some tests to get user feedback.
Through this process, not only did I learned the toolset and methodology of design thinking, but also a mindset and a way of thinking a question.</description>
    </item>
    
    <item>
      <title>大设计</title>
      <link>https://dailydreamer.me/posts/2017-08-26-the-grand-design/</link>
      <pubDate>Sat, 26 Aug 2017 10:47:29 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2017-08-26-the-grand-design/</guid>
      <description>自从高中收到一本作为生日礼物， 时隔多年重读霍金的《大设计》， 颇有感触，想记下一点东西。 《大设计》是一部关于近代物理学对终极问题的探索成果以及霍金对此的哲学思考的书， 英文书名《The Grand Design》更能体现这其中神圣而伟大的意味。 近代物理尤其是量子论的发展使得科学界对终极问题的认识远远领先于哲学界。 为什么存在实在之物而非一无所有？ 我们为什么存在？ 《大设计》试图站在科学的角度来解释这些问题。
定律规则 定律的定义 我们的祖先使用神话和神学来解释这个世界， 甚至牛顿在发现了今天仍在被广泛使用的牛顿三大定律之后还认为是上帝设计了这些自然定律。 今天大多数科学家会说自然定律是一种基于观察到的规律以及为超过它所基于的直接情形提供预言的规则。 自然定律可以是在一族约定的条件下成立， 比如虽然我们现在知道牛顿定律在物体接近光速运动时必须被修正， 但是它依然提供了日常生活中很好的近似。
如果自然由定律制约，那么
 定律的起源是什么？ 定律存在任何例外，或者说奇迹么？ 是否可能只存在一族定律？  神学家、哲学家、科学家对于这些问题给出了不同的答案。
上帝与奇迹 对于第一个问题的传统答案认为定律是上帝的杰作。 但是这只是使用一个神秘来代替另一个而已。 如果使用上帝作为第一个问题的答案， 那么第二个问题随之而来： 是否存在奇迹？
这里存在明显的分歧。 神学家们认为根据《圣经》显然上帝可以施行奇迹。 甚至牛顿也信仰奇迹， 他认为比如行星轨道是如此精密与不稳定， 以至于需要上帝不时的施行奇迹来进行重置。 而以拉普拉斯为代表的科学家则认为没有奇迹。 比如对于行星轨道， 存在周期性的扰动， 使得不需要上帝也可以稳定运行。 科学决定论是他们对第二个问题的答案。
自由意志 由此会引出另一个有趣的问题： 如果科学决定论对人也成立， 那么人还拥有自由意志么？
许多人认为人是科学决定论的例外。 比如笛卡尔将身体和灵魂区分开来以保留自由意志。
然而我们对生物分子基础的理解表明生命过程也是受到物理定律制约的， 正如行星轨道一样。 那么人就没有自由意志了么？ 也不尽然。 数个分子之间的作用的计算已经是一个足够复杂的问题， 而人由\(10^{28}\)数量级的分子构成， 使得即使受到科学决定论的制约， 人的行为也无法由计算预言。 因此我们可以说人是有自由意志的。
有效理论 因为使用基本物理定律去预言人的行为不切实际， 我们采用所谓的有效理论。 有效理论是创造来模仿某种被观察的对象， 而不仔细的描述所有基本过程的框架。
例如，我们不能解人的每个分子和地球每个分子的引力作用的方程， 因此使用和质量有关的公式这个有效理论； 我们不能解复杂反应中每个原子和分子行为的方程， 因此发明了化学这个有效理论； 我们不能解人行为的方程， 因此发明了心理学和经济学等有效理论来预言人的行为。
定律的必然性 对第三个问题的传统答案认为自然的原理由于“必然性”而存在， 即它们是仅有的合乎逻辑的规则， 是上帝精妙设计的杰作。</description>
    </item>
    
    <item>
      <title>一种新科学(2)</title>
      <link>https://dailydreamer.me/posts/2017-08-07-a-new-kind-of-science-2/</link>
      <pubDate>Mon, 07 Aug 2017 23:45:43 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2017-08-07-a-new-kind-of-science-2/</guid>
      <description>摘要 本文是我在上次挖坑之后读完沃尔夫勒姆的著作《一种新科学》后的一些感想。 《一种新科学》是一本贡献和争议并存的书籍，它深入的探讨了元胞自动机的演化，也即计算复杂性而非传统科学方法中数学公式的复杂性，作为宇宙本质的一种可能性。 本文简述了该书的成书背景和内容，探讨了争议和贡献的部分。 《一种新科学》虽然是一种视野的开阔，但是离颠覆现有的科学研究方法还相去甚远。
背景介绍 《一种新科学》是斯蒂芬·沃尔夫勒姆的一本长篇巨著。 在2002年5月14日发行之后的一个星期里，《一种新科学》初版五万册就全部销售一空，在亚马逊排行榜上一度高居榜首，成为2002年夏天最畅销的书。
作者斯蒂芬·沃尔夫勒姆1959年出生于伦敦，父亲是相当成功的作家，母亲是牛津大学的哲学教授。 他幼年聪慧，13岁入伊顿公学，15岁发表首篇粒子物理方面的学术论文。 在获得牛津大学的奖学金并在牛津学习一年之后，即到了美国阿格纳国家实验室的理论高能物理小组工作。 1978年19岁的沃尔夫勒姆受著名物理学家穆雷·盖尔曼之邀去到加州理工学院，从事基本粒子物理学方面的研究，取得显著成就，一年内获得理论物理学博士学位。 1980年沃尔夫勒姆成为加州理工学院一员，与费曼共事。 1981年被授予麦克阿瑟“天才人物”奖，并成为该奖最年轻的获得者。之后他又到了爱因斯坦度过后半生的普林斯顿高级研究所工作，再后来又成为伊利诺斯大学的物理学、数学和计算机科学教授。
1986年27岁的沃尔夫勒姆创立了以他的姓氏命名的沃尔夫勒姆研究公司，成为一位企业家。 1988年他的公司发布了Mathematica，一种科学计算软件。 由于其先进的符号计算理念，成为最广泛使用的数学软件之一。 沃尔夫勒姆也因此实现了财务自由。
其实早在1981年的时候，沃尔夫勒姆就对自然界复杂性起源这一命题产生了兴趣，但是由于研发Mathematica和忙于公司事物，这一兴趣一直被搁置。 90年代初，在Mathematica第二版发行后，公司也渐渐步上正轨。 沃尔夫勒姆便将自己的几乎全部时间都投入了研究和陪伴家人中。在新世纪的开端，百万行代码之后，这些成果变成了1200多页的长篇著作《一种新科学》。
除了畅销之外，沃尔夫勒姆还声称《一种新科学》是科学史上最为重要的一部著作，而他所做的一切不亚于牛顿的贡献。 这种豪言壮语自然十分吸引我去一探究竟。 于是在一个假期里读完了这本大部头。
内容简介 全书围绕元胞自动机这一核心概念进行展开。 元胞自动机是由上个世纪50年代乌尔姆和冯·诺伊曼为了研究机器人自我复制的可能性提出一种离散型动力系统。 元胞自动机是研究复杂系统行为的最初理论框架，也是人工智能的雏形。
设想一个平面上纵横相交的许多直线构成了许多网格，每一个网格就是一个元胞。 这些元胞可以具有一些特征状态，譬如被染成黑、白、红、绿等颜色。 在每个特定的时刻每个元胞只能处于一种特征状态中。 随着时间的增加，或者叫做叠代过程的进行，每个元胞根据周围细胞的状态，按照相同的规则自动地改变它的状态。 这就构成了一台元胞自动机。
一个元胞自动机可以由四个参数唯一决定：
 元胞活动的空间维度数 元胞可能具有的状态集合 元胞改变状态的规则 元胞自动机中各元胞的初始状态  书中主要考虑空间维度为一维的元胞自动机，元胞可能具有的状态只有两种，用颜色表示成黑色或白色，一个元胞只根据自己的状态和相邻的两个元胞的状态来改变自己的状态。 可以很容易计算出这样的一维元胞自动机的规则数有\(2^8=256\)种。
图1：110号元胞自动机规则及20步后的状态
图2：110号元胞自动机250步后的状态
如图1所示，上面是第110（二进制表示\(01101110_2\)）号元胞自动机的规则，下面是其20步之后的状态（0代表白，1代表黑），初始状态为一个黑色元胞。 20步时一切似乎都还跟规则一样简单有规律。 但是如图2所示，250步之后，一些结构开始既不是周期性地也不是完全随机地出现在画面上。
沃尔夫勒姆探索了这256种元胞自动机，以及更高维的2维和3维的情况，发现复杂性增加了但是模式类似。他将元胞自动机划分为四种模式：
 只生成简单重复的图案，比如全黑、全白、或黑白相间如国际象棋棋盘等等 产生一些自相似的分形图案，形成稳定的嵌套结构 产生的图案具有明显的随机性 产生的图案既不是规则的也不是完全随机的复杂图案。它们呈现出某种有序性，但却不能被预测。  第四类元胞自动机是沃尔夫勒姆最感兴趣的，而规则30号和110号则是其中最有代表性的。
书中将随机分为了三类：一是每一步输入都随机结果随机，二是初始输入随机结果随机，如混沌效应，三则是系统内在的随机性，与输入无关。 第四类元胞自动机即是这类。甚至Mathematica的伪随机数生成器都是用30号元胞自动机实现的。 而自然界的许多现象也是如此，那么这种元胞自动机和自然现象有什么关系呢？
一方面来看，宏观上看似连续的事物微观上可能是离散的，比如水流和空气在微观尺度下都是一个个分子。 另一方面，在1994年，数学家马修·库克证明了110号元胞自动机是图灵完备的。 所谓图灵完备即是说它能像计算机一样完成所有的计算任务。
之后的几章里，沃尔夫勒姆用元胞自动机完成了乘法、除法运算，和求素数、求平方根、求π值，甚至解偏微分方程。 并把一维元胞自动机扩展到多维元胞自动机，产生更高的复杂程度，模拟了雪花、生物细胞等等。
更进一步，弹子球、纸牌游戏、布朗运动、三体问题等等问题中的随机性都可以用元胞自动机来解释； 流体的湍流、晶体生长的规律、华尔街股票的涨落也都可用元胞自动机来模拟； 还有自然界中的树叶、贝壳、生物色素沉着等，元胞自动机能生成与它们一模一样的图案和形态。
传统科学在解释这些问题上展示了惊人的复杂性，有些问题甚至不能很好的解释，而沃尔夫勒姆用元胞自动机简单直接的解释了这一切。
之后，他试图使用元胞自动机来解释整个宇宙，认为宇宙就是一个元胞自动机，从简单的规律中产生复杂性。
同行对《一种新科学》的一些评价 在《一种新科学》出版之后，由于其畅销和沃尔夫勒姆可以称之为狂妄的一些论调，很多科学家也对这本书发表了自己的评价。</description>
    </item>
    
    <item>
      <title>游戏化 Gamification</title>
      <link>https://dailydreamer.me/posts/2017-05-21-gamification/</link>
      <pubDate>Sun, 21 May 2017 16:42:02 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2017-05-21-gamification/</guid>
      <description>好久不写博客，把前端重写了一下之后又有了写点什么的冲动。 先把之前囤积的一些内容拿来充充数吧。 这篇是我在Coursera上浏览的一门课程Gamification的总结。 Gamification，译作游戏化，是用游戏元素和游戏设计思想去解决非游戏中的问题。 可以看到这里要解决的问题是非游戏的，只是运用了游戏中的元素和设计思想，所以不要一拍脑袋把游戏化等同于做一个游戏。
那么我为什么对游戏化感兴趣呢，当然是喜欢打游戏啊摔是因为之前在做一个儿童坐姿检测和矫正的项目。 对于成人来说，事情比较简单，愿意去买这个产品的人，你只要提醒他，他便会自己注意改正姿势，事实上Amazon上一款畅销的产品正是这么做的。 但是儿童比较复杂，一般是家长或者学校老师买来产品然后督促他们使用，这时候他们很容易产生很强的逆反心理。 如果只是提醒甚至是惩罚的话，会加重他们的反抗心，比如你不盯着的时候他就不用，或者是伪造一些数据（这种事情我小时候也干过哈哈），这样就违背了产品的初心，削弱了客户价值。 所以一些短期的和长期的激励机制是很有必要的，而这正是游戏化可以做到的。 那么我们言归正传，看看课程里都讲了些什么。
1. 什么是游戏化 游戏化就是用游戏元素和游戏设计思想去解决非游戏中的问题。 两个比较容易理解的例子，一个是Nike+，一个跑步App，使用各种徽章和等级来提升你跑步的激励； 另一个是Zombies Run，也是一个跑步App，设定是你处在一个充满僵尸的世界中，只有拼命奔跑才能拯救自己，比如跑的慢了就会听到僵尸离自己越来越近的声音，通过这种游戏设计来激励你完成跑步计划。
可以看到这里游戏元素指的有分数、任务、资源、虚拟形象、奖励等。 游戏设计思想，指的是就像Zombies Run那样，像一个游戏设计者一样思考这个问题，这一点后面慢慢展开。
游戏化可以被用在三种方面产生价值：
 外部。比如市场、销售、客户参与等活动中。 内部。比如HR、增强生产力、众包等。 行为改变。比如养成健康生活习惯、健身、理财等等。  这里举一个行为改变的例子。 在超速检测的牌子上显示一个彩票抽奖标识，只要没有超速便可参与抽奖，奖金由超速罚单中抽出一部分来构成。 当人们看到没超速可以抽奖的时候，相比之前更加注意自己的车速，从而改变了行为。
总而言之，游戏化可以产生激励作用，并且让人感到有趣。
2. 游戏 游戏化的方法是从游戏中借鉴而来。我认为其中最核心的就是有趣。
什么是游戏? 游戏是由一个松散的目标，一些基本的规则，一个放松的状态构成。 是一个你自愿去克服一些不必要的阻碍的过程。 游戏是一个神奇的圆圈，在这个圈中，你自愿遵循游戏的规则而忽略现实世界的规则。
游戏是一系列有意义的选择 游戏的过程就是一系列有意义的选择（人生又何尝不是呢）。 因此需要维持一些元素的平衡，来保持选择的有意义。 比如规则的限制和对世界的探索，限制太死变失去了一些意外的乐趣，而没有限制的探索则容易让玩家找不到目标。 再比如学习技能和解决问题的平衡等。
3. 游戏化思考 为什么游戏化？ 一个例子，Foursquare通过给在一个地点签到积极的玩家市长称号和徽章来激励玩家参与签到活动。 可以看出，游戏化至少有如下几个好处：激励参与，可视化进度，增加社交，习惯养成。 拿Foursquare例子来说，市长称号和徽章作为奖励十分有趣，激励了人们的参与。 获得徽章的人会把它分享到社交网络，满足自己小小的成就感和虚荣心，这促进了社交。 通过称号和徽章的完成进度可以可视化之前很难直观看到的数据。 而持续的激励则会促进习惯的养成。
像游戏设计师一样思考 每天对着镜子大声念三遍：“我是游戏设计师！”。。。
但是，像游戏设计师一样思考，并不同于成为游戏设计师，也不同于想玩家一样思考。 而是将系统的参与者想象成玩家。
 玩家是游戏的中心 玩家希望有控制感 玩家专心在玩上  所以你的目标就是让玩家们开始玩，一直玩。
设计规则 玩家的旅程被称作英雄之路
 开始的时候要有教学导引，高亮重要的点，提供反馈，提供有限的选项后面再慢慢增加，并且不要让他失败 之后开始整个旅程的框架 最后通过不断练习达到精通  这其中挫折和成就感要相辅相成，恰到好处。
最重要的是营造一种体验，让玩家的内心泛起涟漪，相信对游戏充满热爱的人一定会有这样的感触。走进中世纪的小酒馆看游吟诗人弹唱一曲，或是在山顶眺望洒满天穹的极光。 这里放上一个对Journey的制作人陈星汉的一个采访，说的更加详细。</description>
    </item>
    
    <item>
      <title>移动端体验</title>
      <link>https://dailydreamer.me/posts/2016-06-16-mobile-application-experience/</link>
      <pubDate>Thu, 16 Jun 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2016-06-16-mobile-application-experience/</guid>
      <description>前段时间在Edx上浏览了一门课程Mobile Application Experiences，听课笔记记录如下。
Come up an idea Research method  observation location tour: park, office&amp;hellip; contextual inquiring: working, workout&amp;hellip; think aloud diary logging: taking photo, recording video&amp;hellip; close to the time that happened interview: ask last time they do something rather than the general situation  look at what they are frustrating to do. What kind of role the environment is playing.
Analyze data  flow models: analyze how data flow transfer between subjects conversation analyze: look at the conversation of subjects related to a subject critical incident analyze: look at the place where people get stuck affinity analyze  Affinity analyze From data(bottom up) to find themes.</description>
    </item>
    
    <item>
      <title>买基金给我加薪</title>
      <link>https://dailydreamer.me/posts/2016-06-15-fund-tips/</link>
      <pubDate>Wed, 15 Jun 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2016-06-15-fund-tips/</guid>
      <description>一本有关基金的入门书籍，一些基本知识和理念。
术语 选中长期绩效好的基金。
所选择的基金公司不能只重视一只基金。
基金风险指标：
 标准差：过去一年净值的稳定程度，越低越稳定 beta值：基金波动幅度与打大盘的比值，越低越稳定 夏普指数：每单位反风险带来的收益，越大收益越高。  定投秘籍  越早进场越好 账面亏损无所谓，赎回时要赚钱 定期检视，适时去芜存菁（绩效连续在同类型中处在下游） 只设停利，不设停损（简单计算，年利率是定存的5倍）  单笔投资秘籍  熟悉市场脉动 分批进场，买跌不买涨 定期检视，停利更要止损 懂得分批出场  结合基本面（经济景气）和技术面
基本面  国内生产总值 主要经济指标 美国采购经理指数 消费者物价指数 美联储态度 消费者信心指数  技术面  季线 KD线  结合操作 定投的收益也是市场的重要指标
进场时：先定投，低谷时单笔投资
出场时：先2-3次赎单笔投资，再一次赎回定投
获利后滚入再投资</description>
    </item>
    
    <item>
      <title>从函数式语言想到的</title>
      <link>https://dailydreamer.me/posts/2016-06-09-inspired-by-functional-programing-language/</link>
      <pubDate>Thu, 09 Jun 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2016-06-09-inspired-by-functional-programing-language/</guid>
      <description>最近看了一本书Seven Languages in Seven Weeks。 原来一直都在面向对象编程，对函数式语言了解并不多，看完这本书之后还是很受启发，接触了许多不同语言的新的思想。
各种编程范式 imperative programming 古老的编程范式，以冯诺以曼结构的机器思考的方式编程，如C语言。
object oriented programming 现在正当年的主力编程范式，如Java、C#、ruby、python，以及深度融合了函数式思想但本质还是OOP的scala。
它的分支Prototype-based programming，如JavaScript，是一种十分灵活的编程方式。 没有Class定义，所有的Object都以另一个Object为prototype，可以很灵活的改变原型链上的Object的数据和方法。
logic programming 面向推理逻辑的特定编程范式，是一种高等级的抽象，如prolog，声明定义和推导即可得出特定问题的答案。
functional programming 被认为是下一代的编程范式。 函数式编程范式基于lambda calculus的思想，很早就在大名鼎鼎Lisp中出现。 其核心思想是认为一切程序都可以由纯函数组成，纯函数没有副作用，输入一样则输出必然一样； 所有数据结构都是immutable的，其值不能被改变。
早年由于我们的计算机架构是冯诺以曼结构，其基本操作都是基于副作用的，因此这种函数式编程带来的性能上的极大损失使其没有像命令式编程一样成为主流语言。 现在随着计算机性能的提升以及相关理论和实现的完善，函数式编程的思想带来的好处逐渐体现，并且也积极的影响着其它现在的主流语言。 同时涌现了一批为了兼容现有平台而作出一定妥协的”过渡性语言”，如Scala（Better Java）、Clojure（JVM上的Lisp）、F#（.Net上的OCaml）。
函数式语言的积极影响 基于immutable思想的数据结构 immutable带来的好处是程序的结果更加的可以预测，变量不会在你看不见的地方被偷偷改变。 而且在多核的并行架构下Immutable能够避免复杂的状态和逻辑维护，使程序更加高效简单。
过去Lisp中主要的immutable数据结构是List,在某些情况下这种数据结构的性能非常糟糕（如查找是O(n)）。 而现在一些精巧复杂的树状的数据结构可以兼顾immutable和性能（以一定的存储空间为代价），如Ideal Hash Trees中的Hash array mapped trie(HAMT)。 这篇文章详细讲解了Clojure中的Persistent Vectors（虽然叫Vector但只是接口一样，实际这货是个树）的实现原理。 它基于HAMT，能够在保持immutable维护过去状态以供回滚的同时达到增加、更新、查找都为O(1)的性能。 知乎上的这个讨论介绍了一些其它的相关数据结构。
基于immutable的系统 Nix OS是一种使用Nix packager manager的纯函数式思想的系统。 Nix packager manager也可以在Linux和Mac OS X上使用。 它将每一个软件包都独立开来，升级软件的时候不会影响原来已经安装好的其它版本的该软件，使得软件可以轻松回滚，并且不会出现由于版本导致的各种问题，是ruby的RVM，node.js的NVM，python的virtualenv等等软件所解决问题的终极解决方案。
类型 Haskell拥有强大的类型系统。 static type是指其编译时进行类型检查，strong type是指其类型检查要求类型严格匹配。 配合type inference，Haskell的类型系统做到了你不需要时感受不到，需要清晰接口时可以显示声明。 它永远在保障着程序的正确性，不会产生JavaScript中一些被人广泛诟病的错误（这个视频我笑了好久。。。）。 Scala中也有type inference，但是由于JVM的限制功能很有限。
Haskell中的type class可以优雅的实现generics和polymorphism，并且可以避免很多OOP中因为不能把函数作为一等公民传递（高阶函数）而造成的臃肿的设计模式。 Julia中multiple dispatch更进一步，根据每个参数的类型不同调用不同的函数实现，更符合直觉，且避免了OOP中dynamic dispatch的动态查找带来的性能损失。</description>
    </item>
    
    <item>
      <title>WebRTC简介</title>
      <link>https://dailydreamer.me/posts/2016-05-25-webrtc-introduction/</link>
      <pubDate>Wed, 25 May 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2016-05-25-webrtc-introduction/</guid>
      <description>WebRTC简介 WebRTC是一种在浏览器中无需任何插件的点对点(P2P)实时视频、音频、数据交流协议，其中RTC是实时沟通(Real Time Communication)的缩写。 过去，实时沟通昂贵且实现复杂，需要专用的视频和音频设备及技术，使得将其集成进已有服务昂贵且费时。 后来，Google开源了Gmail和Hangouts中使用的RTC技术，并且参与W3C相关规范的制定。 2011年，WebRTC第一个版本被实现。 现在WebRTC技术已经被WhatsApp, Facebook Messenger等应用广泛使用。
WebRTC主要实现了3个API，getUserMedia、RTCPeerConnection和RTCDataChannel。 其中getUserMedia定义了来获取设备上的视频(包括摄像头输入和屏幕输入等)、音频流的接口。RTCPeerConnection定义了用于处理两个客户端之间的流数据的接口。RTCDataChannel定义了用于处理两个客户端之间任意数据收发的接口。
使用WebRTC过程 使用WebRTC时需要如下步骤：
 使用getUserMedia获取MediaStream流数据，此时可以用Constraints对MediaStream的帧率、宽、高等进行设置。 使用RTCPeerConnection初始化客户端session，将MediaStream附加到session上。 获取网络信息(如IP地址、端口等)，与其他客户端进行Signaling(信令交换)。 该过程使用SDP（Session Description Protocol）协议。 Signaling交换流媒体数据信息(如编码、分辨率等)。 Signaling过程完成，直接点对点交换流媒体数据MediaStream。 (可选)建立RTCDataChannel进行数据交换。  实际应用中，会遇到客户端处于防火墙或NAT之后等复杂情况，这时需要用到STUN协议或TURN协议等来实现防火墙和NAT穿透，获取真实的网络信息。
由于WebRTC在建立session之后流媒体数据是点对点传输，这样虽然很快，但是如果遇到大量客户端的视频会议等场景，客户端之间需要两两连接，对于客户端带宽要求很高。 这时就需要MCU(Multipoint Control Unit)来改变网络拓扑，节省带宽提高性能。
WebRTC在Signaling过程中需要使用其他双向数据协议进行信息交换，如WebSocket或XMPP等。
由于WebRTC标准实现还未最终完全确定，各个浏览器都需开启实验性功能才能使用，可以考虑Chrome插件或者使用Electron封装成桌面程序的形式提供更好的用户体验。</description>
    </item>
    
    <item>
      <title>读过的一些设计书籍</title>
      <link>https://dailydreamer.me/posts/2016-05-24-some-design-books/</link>
      <pubDate>Tue, 24 May 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2016-05-24-some-design-books/</guid>
      <description>最近翻了一下之前记的一些读书笔记，将读过的一些经典的设计书籍总结一下，记录在这里。
不要让我思考 整本书都在传递一个强烈的概念：不要让我思考。用户不喜欢思考，比如用户阅读网页的方式是扫描，选择的时候抱着满意即可、勉强应付的心态。 强迫用户思考会使他们离开你的产品。
下面是几个具体的优化：
 明显标识可点击处，划分页面区域，降低视觉噪音 去掉不必要的文字 统一导航  设计心理学 整本书从心理学的角度看设计。
人认知的基本模型是目标 -&amp;gt; 行动 -&amp;gt; 反馈，好的产品应该有一个好的概念模型
 减少目标到行动认知负担，也即上面提到的不要让我思考 产生合理的反馈  具体有下面几个原则：
 应用存储于外部世界(物理环境)和头脑中(文化标准)的知识，建立界面到功能的自然匹配 简化任务结构 注重可视性，比如一个按钮是一个功能 利用自然和人为的限制因素 考虑可能出现的人为差错，防止错误需要警报或强迫性功能 若无法做到以上几点，就标准化  写给大家看的设计书 这本书主要讲了视觉设计中的几个基本原则：
 亲密性：将相关的项组织在一起，物理位置的接近意味着存在关联 对齐：任何元素都不能在页面上随意摆放，每个元素应当与页面上另一个元素存在某种视觉联系 重复：把现有的一致性向前推进一步 对比：让他们截然不同吧  其他还有注意留白。
设计中的设计 日本设计师原研哉的作品。 一开始只是被书中精美的图片和排版所吸引，但是也收获了不少。
设计师坂茂应原研哉之邀再设计卫生纸时，设计了方形卫生纸。 由于方形的阻力更大会使每次使用的纸变少，而且方形相较于原型更方便运输。 这种再设计可以让人从习以为常的日常中跳脱出来，从另一个角度看问题。
原研哉说，设计师在其受众头脑中创建一种信息建筑，受众通过视觉听觉味觉触觉等感官信息，以及被外界重新唤醒的记忆来构建信息建筑。
原研哉对书和纸的看法：书作为一种存储信息的媒介可能有诸多不便。 但是如果我们好好观察一下信息与个人的关系，会发现重要的其实是我们能多深入的理解信息。 就书而言，我们会有更愉快的用户体验，我们会更中意于那些以适当重量和质地的材料呈现的信息。 这可能就像食物与人类的关系一样。 因为电子媒介的兴起，纸终于能做他该做的事情了——充当一种本性迷人的材料。
他还是无印良品咨询委员会委员。 无印良品的理念是无设计的设计，简单，追求的不是这个好而是这样就好。</description>
    </item>
    
    <item>
      <title>DOM和DOM Event</title>
      <link>https://dailydreamer.me/posts/2016-04-25-dom-and-dom-event/</link>
      <pubDate>Mon, 25 Apr 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2016-04-25-dom-and-dom-event/</guid>
      <description>DOM和HTML，JavaScript，CSS的关系 Document Object Model(DOM)是W3C制定的一种语言无关的面向对象的文档模型，规定了一组可编程的interface需要实现的属性和方法。 HTML和XML文档实现了DOM，因此拥有面向对象的特性，其结构、样式、内容等可以被其他语言的DOM实现操纵。 DOM Level 4是2015年的最新一版标准。
HTML中&amp;lt;script&amp;gt;元素中嵌入的JavaScript就是DOM的一种实现，如下所示：
var paragraphs = document.getElementsByTagName(&amp;#34;P&amp;#34;); // paragraphs[0] is the first &amp;lt;p&amp;gt; element // paragraphs[1] is the second &amp;lt;p&amp;gt; element, etc. alert(paragraphs[0].nodeName); 其中document对象，getElementsByTagName方法，alert方法，nodeName属性均是DOM标准规定的。
你也可以用其它语言操作DOM，如下的Python示例：
# Python DOM example import xml.dom.minidom as m doc = m.parse(&amp;#34;test.xml&amp;#34;); doc.nodeName # DOM property of document object; p_list = doc.getElementsByTagName(&amp;#34;para&amp;#34;); HTML是一种文档标记语言，HTML元素除了实现DOM的interface之外，还实现了HTML标准中规定的一些interface。如下示例：
var table = document.getElementById(&amp;#34;table&amp;#34;); var tableAttrs = table.attributes; // Node/Element interface for (var i = 0; i &amp;lt; tableAttrs.</description>
    </item>
    
    <item>
      <title>CSS Cheat Sheet</title>
      <link>https://dailydreamer.me/posts/2016-04-14-css-cheat-sheet/</link>
      <pubDate>Thu, 14 Apr 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2016-04-14-css-cheat-sheet/</guid>
      <description>HTML block element块级元素，撑满一行
inline element行内元素，宽度包围内容
CSS原理 选择符 a, b {} 同时选中a和b
a b {} a是b的祖先元素时选中b
a &amp;gt; b {} a是b的父元素时选中b
a + b {} a紧邻b时选中b
a ~ b {} a和b是同胞时选中b
* {} 全部选中
.a {} 选中a类
#a {} 选中id为a
a.b {} 选中同时为a标签和b类
.a.b {} 选中同时为a类和b类
a[b] {} 选中a标签中带有b属性的
a[b=c] {} 选中a标签中b属性值为c的
伪类 a标签 a:link a:visited a:hover a:active
a:focus a:target
一组同胞元素中的第几个 a:first-child a:last-child a:nth-child(n) a:nth-child(odd) a:nth-child(even)
伪元素 a::first-letter a::first-line
a::before a::after</description>
    </item>
    
    <item>
      <title>单页应用JWT身份认证</title>
      <link>https://dailydreamer.me/posts/2016-04-09-spa-jwt-auth/</link>
      <pubDate>Sat, 09 Apr 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2016-04-09-spa-jwt-auth/</guid>
      <description>最近在开发一个单页应用，采用了前后端分离的策略，即后端只提供RESTful接口，前端进行路由，通过Ajax和后端交互。 为了保持RESTful服务的无状态，要避免使用sesseion来保存登录状态，可以使用token方式来进行认证。 这篇博客就来说一下利用JWT(JSON Web Tokens)进行身份认证，以及如何防范MITM，XSS与CSRF攻击。
JWT JWT是RFC 7159规范，利用JSON和一种可选的签名算法定义了一种紧凑且自恰的结构。 相比基于XML的SAML方式更加简单紧凑，节省流量且JSON格式方便处理。 相比基于session的认证方式不用在服务器端维护状态，易于扩展；不用查询数据库，性能更好；可以授权给别的应用。 缺点是实现过于复杂，很多语言库都没有实现完整的JWT规范。
JWT由三部分组成，Header.Payload.Signature。
Header Header包含签名算法和type，如下：
{ &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;, &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34; } Base64编码后即为Header。
Payload 主体内容部分。有一些保留属性，如iss (issuer), exp (expiration time), sub (subject), aud (audience)等。也可以声明私有属性。
如下：
{ &amp;#34;sub&amp;#34;: &amp;#34;1234567890&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;John Doe&amp;#34;, &amp;#34;admin&amp;#34;: true } Base64编码后即为Payload。
Signature 签名部分，生成过程如下：
alg( base64UrlEncode(header) + &amp;#34;.&amp;#34; + base64UrlEncode(payload), secret) 其中alg为Header中声明的签名算法，常用的如SHA256等。 结合secret校对签名可以保证JWT的完整性和不可伪造性。
身份验证过程 后端API除了注册和登录外的需要身份验证的接口都对JWT签名进行验证，不通过则返回401 Unauthorized，保护API。 用户注册登录后生成JWT返回用户，用户访问受保护的API时需要随请求发送JWT至服务器端。
两种常见的安全威胁 接下来看看单页应用开发中几种常见的安全威胁：MITM(Man-In-The-Middle)，XSS(Cross-site scripting)和CSRF(Cross Site Request Forgery)。
MITM MITM是指在数据传输过程中窃听甚至篡改线路中的数据，如窃听WIFI和ARP欺骗等等。 这里我们在应用层主要使用SSL加密，即HTTPS防范它。 在后端response的header的cookie设置Secure字段，强制cookie使用HTTPS传输。
XSS XSS是指将恶意脚本注入站点，如在用户聊天框输入的地方输入如下内容
&amp;lt;img src=x onerror=&amp;#34;alert(XSS!</description>
    </item>
    
    <item>
      <title>CORS解决单页应用跨域问题</title>
      <link>https://dailydreamer.me/posts/2016-04-08-cors-solve-same-origin-policy-problem/</link>
      <pubDate>Fri, 08 Apr 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2016-04-08-cors-solve-same-origin-policy-problem/</guid>
      <description>同源策略 最近在开发一个单页应用，采用了前后端分离的策略，即后端只提供RESTful接口，前端进行路由，通过Ajax和后端交互。 这时前端和后端部署在不同的服务器上。 而浏览器为了安全，运行在浏览器中的Javascript脚本受到同源策略限制。
同源是指协议+主机名+端口号全部相同，称为同源。 详细见下表，是跟&amp;quot;http://www.example.com/dir/page.html&amp;quot;做比较。
   Compared URL Outcome Reason     http://www.example.com/dir/page2.html Success Same protocol, host and port   http://www.example.com/dir2/other.html Success Same protocol, host and port   http://username:password@www.example.com/dir2/other.html Success Same protocol, host and port   http://www.example.com:81/dir/other.html Failure Same protocol and host but different port   https://www.example.com/dir/other.html Failure Different protocol   http://en.example.com/dir/other.html Failure Different host   http://example.com/dir/other.html Failure Different host (exact match required)   http://v2.</description>
    </item>
    
    <item>
      <title>一种新科学</title>
      <link>https://dailydreamer.me/posts/2016-03-20-a-new-kind-of-science/</link>
      <pubDate>Sun, 20 Mar 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2016-03-20-a-new-kind-of-science/</guid>
      <description>本书作者是Mathematica之父Stephen Wolfram。 他在完成Mathematica后挣了一大笔钱，然后几十年一直在搞自己喜欢的研究和探索，最终著成本书（论经济基础对研究的重要性）。 虽然书中的研究缺少确实的证据而更多的是作者的猜测，但是以目前的科学也不足以证伪。 不过有计算复杂性科学家发过paper评判这种没有同行评阅和修改的出书模式，并且质疑了其内容的价值。 但是作为思路开阔一读也未尝不可。
而且这本书实在是太长了，并且充满了各种论断但是缺少证据，最终没有看完，日后有机会再补完。
The Foundation for a New Kind of Science 实际上系统理论没必要必须建立在传统数学规律之上。 使用传统数学规则经常无法使用简单的规则解释复杂的自然现象，但是遵从简单规律的程序却可以产生复杂的结果。
Principle of Computational Equivalence: Whenever one sees behavior that is not obviously simple - in essentially any system - it can be thought of as correspoding to a computation of equivalent sophitication.
这个原理揭示了传统数学规则的局限性，它只能解释简单的系统因为它大大简化了计算复杂度。
现在的物理太依赖连续的数学表示或概率，但是离散的其实更简单，并且可以解释很多基本现象。
现在数学不能解释复杂的生物系统，而简单程序可以。
A new kind of science不仅能够解释各个学科的复杂问题，也能对经典的基础问题进行解释。
The Crucial Experiment How do simple program behave? 细胞自动机即使从简单条件开始，遵从简单条件发展，也会展示惊人的复杂性，正如我们在自然中看到的。
尽管每个cell都遵从相同的规律，但是因为环境的不同，它们的行为也不同。
The need for a new intuition 细胞自动机的复杂性与我们认为一个复杂事物必然构成复杂的直觉相反，而这种直觉可能来自于工程中，那里我们从功能出发，逐步将系统分解到细节，我们能预测系统的一切行为。 但是却不是这样，事实上类似细胞自动机这种不可预测的结构在自然中很常见。</description>
    </item>
    
    <item>
      <title>关键对话</title>
      <link>https://dailydreamer.me/posts/2016-03-07-difficult-conversation/</link>
      <pubDate>Mon, 07 Mar 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2016-03-07-difficult-conversation/</guid>
      <description>Difficult Conversation(关键对话)，是指让你感到害怕和焦虑的对话，比如家人间、情侣间的吵架，上下级间的工作安排等。 本书对这种对话进行了深入的剖析，将问题分解看透彻之后可以更好的处理这种对话。
The problem 关键对话的结构：
  What happend
  The feelings conversation
  The identity conversation
  我们不能改变周围，但是能改变的是对待这些挑战的反应。
What happend 不要一上来就认为你是对的，试图搞清楚对方的感知、解释和价值观。
对方的意图可能很复杂，不要预先假定是坏的。
不要一味责备对方，试图弄清楚双方对造成问题的贡献。
Feeling conversation 情感是困难对话的核心。
Identity conversation 调整你的认知失调造成的困难感是最有技巧可学习的。
Shift to a learning stance What happend conversation Stop arguing about who&amp;rsquo;s right, explore each other&amp;rsquo;s stories. 每个人对故事的解读都是有道理的。 争吵阻碍了我们从他人的角度理解故事。
为什么会有不同的故事解读：我们注意到的和获取到的信息不同。 我们有不同的解读，受过去经历和隐含的规则的影响。
对他人的故事感到好奇。
有时候了解对方的立场不代表一定要同意，比如提出分手的时候，承认双方的立场。
Don&amp;rsquo;t assume they mean it: disentangle intent from impact. 我们假设别人的意图通常是错的。
试图去理解自己复杂的意图会给对方传递积极和在乎的信号。
将你的意图告诉对方，试图弄清楚你的行为对对方的影响。
Abandon blame: map the contribution system blame是关于judging但是contribution是关于understanding并且looking forward。</description>
    </item>
    
    <item>
      <title>神话的力量</title>
      <link>https://dailydreamer.me/posts/2016-01-13-power-of-myth/</link>
      <pubDate>Wed, 13 Jan 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2016-01-13-power-of-myth/</guid>
      <description>前些年读过的一本很神奇的书，记下一些富有力量的话语，有机会要重新温习。
善与恶 善恶是相对于你的立场而定的。 对某人来说是善，对其他人可能就是恶。 但对上帝而言，二者并无不同。 你扮演着自己的角色，即使在你了解他有多可怕后也不退缩，而能把它看成是神秘超越而美妙惊奇世界之前奏。
生命最大的挑战之一，就是肯定你心里最讨厌的人或事。 你不能说不应该有毒蛇，因为那是生命的本来面目。 但是在行动中，假如你看到毒蛇咬人，你会杀了他。 那并不是否定蛇，而是对那个情景说不。
这两句话从更高的层面看待了善与恶的相对性。 每个人都有着自己的使命与愿景，与你相顺的于你即善，与你相逆的于你即恶。 知道没有绝对的善与恶是成熟的标志。
人生的态度 生命一切皆苦，顺其自然，便是喜悦。 但是顺其自然，并不代表自暴自弃随波逐流，这不是必然的结论。 你将参与人生这场游戏，竭尽所能。
不论你在何处，只要遵循你内心直觉的喜悦，你就可以享受到永恒生命之泉的那份清新，它一直在你内心的生命中。
这世界上许多人都不曾停下来，倾听自己或邻人，学习什么是该做的，和什么是他们的生活价值。 对物质的追求是无止境的，但你终将在40岁意识到你已到达人生的巅峰，只有走下坡路的日子可活而陷入深深的忧虑。
你只有一生可活，你不需要为他人而活，要活的专注，遵循内心直觉的喜悦。
这几句话曾经同银他妈，以及后来读到的尼采的永劫回归理论，一起深刻的影响了我的人生抉择。遵从内心的喜悦吧。
神话在今天的意义 艺术家是今日的巫师。而作为普通人，我们应该读书来理解自然的神性。 读对的人写的书，你的心就会被带到某个层次，你可因此而拥有一种美好，温和，慢慢燃烧的喜悦。
不同的个体本是一体的，你们本来就是一个生命的两面，当下的分隔，只不过是在时空条件下，体验形体的方式结果罢了。我们的真实在于与所有的生命结合一致。 这个形而上的真理，可以在危机之下立刻体验到。因为它就是你生命的真理。
整本书读完后，可以感受到神话不只是过去的故事，而是人类祖先古老的共同记忆和模范； 而今天的生活中，虽然不再相信神话表面描述的故事，但是其内涵却依然深深的烙印在我们心底，一直发挥着作用。</description>
    </item>
    
    <item>
      <title>一次与CTF的邂逅</title>
      <link>https://dailydreamer.me/posts/2015-11-23-meet-ctf/</link>
      <pubDate>Mon, 23 Nov 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2015-11-23-meet-ctf/</guid>
      <description>机缘巧合做了两道CTF二进制题目，谨以此为记。
第一题 recho 主要参考这篇博客，ruby实现，也有人推荐了这篇python实现版，使用了pwntools。
第一题中handle()函数buf大小256Byte，但是recv_line()函数接受用户输入没有限制长度，存在BOF漏洞可以利用。
为了方便本地调试，将源代码中关于drop_priv()相关函数去除后，本地编译。
为了能够在64位linux上编译和执行32位文件，需要安装32位环境。以Ubuntu14.04为例，执行
sudo dpkg --add-architecture i386 sudo apt-get update sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 gcc-multilib 即可。
编译时使用命令
gcc -fno-stack-protector -g -o recholocal -m32 recholocal.c 注意使用-m32参数编译成32位，-fno-stack-protector关闭stack canary检测，-g方便gdb调试。
运行./recholocal后通过命令
ps -aux | grep recholocal 查看其进程号，通过
gdb atach pid 来调试该进程。
set follow-fork-mode child 可以使gdb在程序fork()后跟随子进程。
在程序中找到recvline()和sendlen()，使用
objdump -d recholocal | grep recvline 获取地址，使用他们来对内存进行写和读。 注意recv_line最后以\n结束。 还有程序最开始调用的sendstr()函数会将是将payload的strlen()长度发送，如果payload中有0x00就会被截断发送。
使用objdump -x recholocal可以查看各个section的位置和布局，找到一个可读可写又足够大的section来存放我们的字符串参数，如.bss或.dynamic等。 发现.dynamic的位置是0x0804a10c。
为了对付ALSR，需要先知道libc中某个函数的运行时地址，使用sendlen()将其发送过来，再加上system()相对这个函数的偏移，写入某个函数got表项，在调用该函数就是相当于调用了system()。
使用
objdump -R recholocal | grep __libc_start_main 发现__libc_start_main()的got表项地址为0x0804a040。</description>
    </item>
    
    <item>
      <title>多个github账号的ssh key切换</title>
      <link>https://dailydreamer.me/posts/2015-10-30-ssh-config/</link>
      <pubDate>Fri, 30 Oct 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2015-10-30-ssh-config/</guid>
      <description>当拥有多个github账号并且想通过ssh方式同步代码时，就需要在多个账号的ssh key间切换。
github多个账号ssh key切换 配置ssh的config文件 使用ssh-keygen -t rsa -C &amp;quot;youremail@xxx.com&amp;quot;生成两个ssh key之后，在~/.ssh/下添加一个config文件，内容如下:
Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Host second.github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_second 设置远程仓库的ssh地址 只需要让ssh的目标主机地址变为你写的Host即可。
git remote add origin git@second.github.com:myname/myrepo.git 更加深入的利用ssh config文件可以参考这篇文章。</description>
    </item>
    
    <item>
      <title>禅与摩托车维修的艺术</title>
      <link>https://dailydreamer.me/posts/2015-08-04-zen-and-the-art-of-motorcycle-maintenance/</link>
      <pubDate>Tue, 04 Aug 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2015-08-04-zen-and-the-art-of-motorcycle-maintenance/</guid>
      <description>第三章 科学就是现代的鬼神。 过去人们使用鬼神解释自然现象，现代人们使用所谓的科学来解释。 这些都只存在于人们心里，是对自然规律的一种认识和解释。
第四章 一个世纪前和小孩一起读古典的方式：读两句话，等他一连串的提问，然后回答他的问题。
第六章 使用二分法，将人类的认知分为古典的和浪漫的。 古典的认知认为这个世界是由一些基本形式组成的；浪漫的认知则从表象来观察，主要的是情感而非事实。
斐德洛的古典中有名为分析的小刀。
第七章 我们选择性的筛选出感官接受的结果，浪漫的认知直接针对这个结果，而古典的认知使用分析的小刀对其进行分类，并且注重相互之间的联系。
第八章 摩托车的外观是浪漫的，但是内在的运作是纯古典的。 他的外壳就是古典和浪漫的分界。
摩托车也是一种系统，正如政府和军队。 只要架构系统的理性还在，系统就可以被轻易重新构建。
第九章 逻辑使你在系统中找到自己的路。逻辑有归纳法和演绎法。 两种方法交替使用就能解决问题。
第十章 前面铺垫了那么多，这一章开始渐渐接近了问题的核心。
在科学的殿堂中有许多深宅大院。 有的人倾心科学是因为优越的智力，有的人则完全为了实用的目的。 如果上帝派来的天使将上面两种人从殿中驱逐出去，那么殿里会空旷许多。 那些获得天使青睐的人，有些古怪、沉默和孤独，除了同是不受欢迎的人外，彼此之间少有相似之处。 斐德洛认为自己就是这样的人。 所以当他提出科学困扰他的问题时，没有人真正关心。于是他开始了心灵探索的道路。
困扰他的问题是什么呢?
科学研究，或者说自然科学的研究，是通过观察现象做出假设然后实验证明得出结论。 爱因斯坦认为，根据进化论所显示的，在历史上任何一刻，所有可想见的存在，总有一个会证明它比其他一切要优越。 但是斐德洛认为现在由于眼界的广阔，假设出现的速度远大于验证他们的速度，因此科学真理持续的时间越来越短，很容易被后来验证的假设推翻。 各种假设和定理的增加，把人从唯一绝对的真理，引向多元、摇摆不定、相对的世界，是造成社会和思想价值混乱的元凶。 现在的理性结构不符合社会所需，然而在情感上空虚，在美学上没有任何表现。 造成社会上一些人在整个文明的理性架构下，活的盲目而疏离，找寻不到答案。
我以为因为斐德洛是搞生物化学的，如果他从事过数学研究就会发现这个所有自然科学的根基是一门注重概念的演绎科学，不是使用实验证明假设，而是靠演绎。 依靠最底下的公理构建起整个大树。 每当物理学家走的飞快依靠直觉提出各种假设，数学总是跟在后面谨慎的证明。 虽然偶尔出现过改变公理构建出不同大树的情况，但总体上没有这个问题。 壮哉我大数学~
第十一章 斐德洛通过哲学探索人类心灵的高山地带。
大卫·休谟的经验主义，认为我们的知识都来自于感官。 但是会得出推论说整个世界出自于人的想象。
康德试图推翻经验主义。 他认为我们人性之中有一种直觉，我们认为的现实，是直觉和感官接收到的讯息融合而成。 我们通过感官接收到的讯息不断修正直觉，直觉也在过滤着感官接收到的讯息。
斐德洛认为康德的《纯粹理性批判》中有着属于理性自身的丑陋。
第十二章 斐德洛之后去了印度研究东方哲学，他的知识在那儿出现了混乱。 他离开了印度，放弃了对理性的追求，念了新闻学位，结婚生子。
放下了之后，反而成熟的更快。 于是他变成我们的作者又开始继续追寻，通过这次旅途。
第十三章 斐德洛说，真正的大学是心灵的世界，是多少世纪以来流传给我们的理性思想，大学的本质在于通过教授们流传下来的理性自身。 物质的大学只是为真正的理性教会提供了生存的环境。
斐德洛因为对科学理性缺乏信心，所以才成为了理性教会的狂热研究者。
第十四章 科学没有和人的心灵连在一起，所以在盲目之中暴露出了丑陋的一面。 解决的方法不是抛弃或否定理性，而是扩展理性的内涵。
哥伦布发现新大陆时也拓展了整个文化的根基，当时人们抛弃了中古世纪的价值观，接受理性的新世界。
第十五章 重返斐德洛教书的地方，探寻良质的意义。
第十六章 良质的第一部分，模仿是一种罪恶。 是学校的教育造成了这一点，他试图取消分数和学位制度，但是并没有得到好的结果。
第十七章 良质是说一篇优秀的作品不需要任何规则，不需要任何理论，然而他指向某种东西，非常真实。 不是模仿，而是內驱的创造。
第十八章 不去界定良质，不用理性去分析良质。使用理性来支持这一观点。</description>
    </item>
    
    <item>
      <title>人人都是产品经理</title>
      <link>https://dailydreamer.me/posts/2015-07-25-product-manager/</link>
      <pubDate>Sat, 25 Jul 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2015-07-25-product-manager/</guid>
      <description>写给-1到3岁的产品经理 我们到底是不是产品经理 产品是可以满足人需求的载体，商业产品在用户需求和商业目标之间平衡。
宝洁产生了产品经理的概念。
传统产品经理是品牌经理或产品市场经理，重在营销。
   Type 典型的传统行业 互联网、软件行业     行业形态 成熟行业 新兴行业   产品形态与成本结构 实物 虚拟物品   生命周期 几年 几个月   盈利模式 单一卖产品赚钱 多元盈利   用户心态 花钱买 免费用    互联网软件行业产品创新多，产品经理注重产品功能规划。
产品多为虚拟物品，因此注重需求分析和设计细节。
产品生命周期短，产品经理在项目完成度和产品质量间做平衡。
盈利模式更多元，靠用户数量，产品经理重视用户研究和用户需求。
用户免费用，更换成本小，用户是上帝，重视用户体验。
管理是在资源不足的情况下把事情做成的能力。而资源不足是常态，因此你已是产品经理。
我真的想做，怎么入行 喜欢做产品，并且不是站在用户角度，而是站在产品经理角度看待产品。
研究产品经理招聘广告并总形成调研报告。
一个需求的奋斗史 用户研究-&amp;gt;需求采集-&amp;gt;需求分析-&amp;gt;需求筛选-&amp;gt;需求管理。
需求采集的大生产运功 明确目标，明确采集方法，制定采集计划，执行采集，资料整理，然后进需求分析。
定性的说：用户访谈。
  为避免说的和做的不一致，可以尽量在用户和产品交互的场合下进行。
  要避免样本少，以偏概全。
  牢记访谈目的，不要太强势，也不要被用户代跑。
  避免一组固定的问题。这会让用户有被审问的感觉。
  首先关注目标，任务其次，多问为什么这么做。</description>
    </item>
    
    <item>
      <title>WPF全局隐藏鼠标</title>
      <link>https://dailydreamer.me/posts/2015-06-29-hiding-mouse-globally-in-wpf/</link>
      <pubDate>Mon, 29 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2015-06-29-hiding-mouse-globally-in-wpf/</guid>
      <description>前些日子使用WPF实现了一个填平两个屏幕间缝隙的小程序，在那里面需要让光标在两个屏幕间的时候将其隐藏。 在一个程序内部隐藏鼠标很容易，在WPF中只需设置Mouse.OverrideCursor = Cursors.None。 但是当程序最小化后鼠标还能隐藏着实费了一番功夫。 大致有如下几种思路。
  将系统的光标图标设置为一个blank.cur的空图标，要显示时再替换回来，这样就可以全局隐藏鼠标，具体方法可以看这里。 但是这种方法有一些问题，一个是需要将系统所有状态的光标图标都替换为空图标，十分繁琐； 而且非常危险，因为一旦你的程序在隐藏鼠标时崩溃，那么鼠标就消失了！ 只有重启才能重新显示鼠标。
  要隐藏鼠标时将鼠标的位置一直设置在右下角。 这样虽然看不见鼠标了，但是有时会触发侧边栏，尤其是Win8的右边栏； 同时无法知道用户此时已经将光标移动到哪里了，因此也不是非常好用。
  最后终于找到了一种十分讨巧的方法。 就是在要隐藏光标的范围内新建一个透明窗口，然后在这个窗口上将光标隐藏。 大致代码如下：
  Window cursorWin; private void cursorWinInit() { cursorWin = new Window(); cursorWin.Left = bound - (W + hideBuffer); cursorWin.Top = 0; cursorWin.Width = 2 * (W + hideBuffer); cursorWin.Height = maxHeight; cursorWin.ShowInTaskbar = false; //禁止在任务栏显示  cursorWin.WindowStyle = WindowStyle.None; //无边框  cursorWin.AllowsTransparency = true; //透明  cursorWin.Topmost = true; //置顶  cursorWin.</description>
    </item>
    
    <item>
      <title>UNIX编程艺术</title>
      <link>https://dailydreamer.me/posts/2015-06-28-unix-programming-art/</link>
      <pubDate>Sun, 28 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2015-06-28-unix-programming-art/</guid>
      <description>这本书极为经典，虽然后半部分的细节有些过时，但是前面的哲学影响深远且富有启发性。
哲学 UNIX有它独有的文化和哲学，它富有生命力且影响深远。UNIX诞生于1969年，而今天化身为Linux、BSD、MacOS X等，应用广泛且强大。
UNIX文件在字节层次上再无结构，文件删除了无法恢复，作业控制有欠精致，命名方式混乱。这些都是UNIX的缺点。
最大的争议在于，提供机制，而不是策略。 比如X Window，提供一套极端通用的图形操作，将界面的观感(策略)推后到应用层。 这使得UNIX可以提供很多行为选项和令人眼花缭乱的定制功能。 然而它的代价就是当用户“可以”设置自己的策略时，他们“必须”设置自己的策略。 这使得UNIX失去了很多非技术用户，但是策略相对短寿，机制才会长存。 只提供机制才能使得UNIX长久保鲜。
同时，UNIX还有着及其丰富和优秀的外围文化。 开源软件，跨平台可移植和开放标准(IEEE的可移植操作系统标准POS很快被大家加后缀变成了POSIX)，Internet和TCP/IP协议，开源社区，从头到脚的灵活性(在其他系统中，完成设计者预见的任务容易，但是设计者没有预料到的就很难)，以及UNIX hack很有乐趣。
UNIX哲学起源与Ken Thompson早期关于如何设计一个服务接口简洁、小巧精干的操作系统的思考，一路成长且博采众长。 UNIX管道的发明人Doug Mcllroy总结，UNIX哲学是一个程序只做一件事，并做好。程序要能协作。 程序要能处理文本流，因为这是最通用的接口。整体上，UNIX哲学可以概括为一下几点：
  模块原则：使用简洁的接口拼合简单的部件
编制复杂软件而又不至于一败涂地的唯一非方法就是降低其整体复杂度，用清晰的接口把若干简单的模块组合成一个复杂的软件。
  清晰原则：清晰胜于机巧
些程序时，要想到你不是写给计算机看，而是写给人看的。优雅而清晰的代码不仅不容易崩溃，而且更易于让后来的修改者立刻理解。
  组合原则：设计时考虑拼接
在输入输出方面，UNIX传统极力提倡采用简单、文本化、面向流、设备无关的格式，否则很难和其它程序衔接。要想让程序具有组合性，就要使程序彼此独立。
  分离原则：策略同机制分离，接口同引擎分离
策略短寿，机制长存。在探索新策略的时候尽量不要打破机制，这样也可以为机制编写更好的测试。
在GUI之外也可以应用这个原则，如Emacs编辑器使用内嵌的脚本语言Lisp解释器来控制用C编写的编辑原语操作。
  简洁原则：设计要简洁，复杂度要低
复杂的东西代价更高，bug更多。以简洁为美，总设法将程序系统分解成几个能够协作的小部分。
  透明性原则：设计要可见，以便审查和调试。
透明性是说一眼能看出软件是在做什么以及怎样做的，显见性是说程序带有监视和显示内部状态的功能。尽早设置调试选项。
  健壮原则：健壮源于透明与简洁
健壮性指在超出设计者预想外的条件下也能运行良好。
  表示原则：把知识叠入数据以求逻辑质朴而健壮。
数据比变成逻辑更容易驾驭。主动将代码的复杂度转移到数据之中去。
  通俗原则：接口设计避免标新立异
  缄默原则：如果一个程序没什么好说的，就保持沉默
只输出重要的东西。
  补救原则：出现异常时，马上退出并给出足量错误信息
“宽容的收，谨慎的发”。
  经济原则：宁花机器一分，不花程序员一秒
  生成原则：避免手工hack，尽量编写程序去生成程序</description>
    </item>
    
    <item>
      <title>Python解析XML与生成迭代器</title>
      <link>https://dailydreamer.me/posts/2015-06-23-python-yeild-and-parse-xml/</link>
      <pubDate>Tue, 23 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2015-06-23-python-yeild-and-parse-xml/</guid>
      <description>这次来看看Python解析XML与生成迭代器。
迭代器 使用yield操作符可以使一个函数变成迭代器。如下一段测试代码：
def genTest(n): print 1 print 2 for i in range(3,n+1): yield i print n+1 print n+2 if __name__ == &amp;#39;__main__&amp;#39;: for i in genTest(5): print i 输出如下：
1 2 3 4 5 6 7 可以看出第一次调用genTest()时执行了1,2位置的代码。 之后yield将i返回给caller的i，然后再次调用时继续从genTest上次yield之后的代码执行，直至最后return停止，迭代结束。
Python解析XML Python解析XML有许多种方法，它们各有特色。
ElementTree ElementTree是python xml解析的一种轻量级实现。 它将XMl文件读取到内存中以一棵树的形式存储。 它速度快且方便使用，但是不能读取不规范的XMl文件，并且会一次将XML文件解析入内存。 因此适合解析一些小型的XML文件。 cElementTree是它的一个C优化过的版本。
示例代码如下：
def readXMLET(filename): try: import xml.etree.cElementTree as ET except ImportError: import xml.etree.ElementTree as ET tree = ET.ElementTree(file=filename) print &amp;#39;read finish!&amp;#39; root = tree.</description>
    </item>
    
    <item>
      <title>ElasticSearch搜索配置（2）</title>
      <link>https://dailydreamer.me/posts/2015-06-22-elasticsearch-config-2/</link>
      <pubDate>Mon, 22 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2015-06-22-elasticsearch-config-2/</guid>
      <description>这次再来说说ElasticSearch的其他一些特性。
Bulk 使用Index进行索引是一次索引一条doc，而bulk提供了批量索引的功能，能够显著的减少索引时间。 经过实际测试，对于1个100Mb约20K条doc，向远程服务器单节点发起索引的完成时间对比如下表。
   chunck_size time/s     200 298.34   500 216.84   1000 169.64   2000 164.71    可以看出chunck_size在一个合适的区间时可以显著减少索引时间，而chunck_size的选取也和一个doc的大小有关。
这里是官方文档。
ElasticSearch的python API中对bulk进行了封装，有helpers.streaming_bulk和helpers.bulk两个方法，官方文档在这。大致使用方法如下：
for success, fail in helpers.streaming_bulk(es, genDoc(filename), index=INDEX, doc_type=DOCTYPE, chunk_size=1000): print &amp;#39;success: &amp;#39;, success success, fail = helpers.bulk(es, genDoc(filename), index=INDEX, doc_type=DOCTYPE, chunk_size=1000) 其中geDoc()是一个迭代器。 这两个方法的区别在于bulk调用了streaming_bulk并将信息一起返回。
拼音搜索 对于中文内容较多的索引，如果能够使用拼音搜索会十分方便。 ElasticSearch有插件elasticsearch-analysis-pinyin可以实现这个功能。 它可以将中文转化为拼音字母，在建立索引的时候就可以在倒排列表中使对应的拼音字母关联到包含中文的Doc上。
为了将拼音搜索的索引和IK分词的索引结合，需要用到另一个插件elasticsearch-analysis-combo。 它可以将两个Analyzer的结果合并起来得到一个新的Analyzer。
基本的配置如下。
index: analysis: analyzer: ik: alias: [news_analyzer_ik,ik_analyzer] type: org.</description>
    </item>
    
    <item>
      <title>ElasticSearch搜索配置（1）</title>
      <link>https://dailydreamer.me/posts/2015-06-05-elasticsearch-config-1/</link>
      <pubDate>Fri, 05 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2015-06-05-elasticsearch-config-1/</guid>
      <description>最近在用ElasticSearch做一些搜索，来谈谈其中用到的一些特性。
ElasticSearch是基于Lucene的分布式包装，其中每一个分片或一个副本都是一个Lucene实例。 ElasticSearch实现了很好的扩展性和冗余，自动负载均衡。可以通过Restful API与ElasticSearch集群交互。 我使用的是python API。
可以参考ElasticSearch权威指南，讲解非常清楚。
建立索引 建立索引的时候可以使用mapping建立对每个字段建立映射。
mapping_body = { &amp;#39;mappings&amp;#39;:{ &amp;#39;tweet&amp;#39;:{ &amp;#34;properties&amp;#34;:{ &amp;#39;text&amp;#39;:{&amp;#39;type&amp;#39;:&amp;#39;string&amp;#39;, &amp;#39;index&amp;#39;:&amp;#39;analyzed&amp;#39;, &amp;#39;analyzer&amp;#39;:&amp;#39;ik_smart&amp;#39;, &amp;#39;similarity&amp;#39;: &amp;#39;BM25&amp;#39;} } } } } es.indices.create(index=&amp;#39;test-index&amp;#39;, body=mapping_body) 上面为&amp;rsquo;test-index&amp;rsquo;的索引中&amp;rsquo;tweet&amp;rsquo;的type中&amp;rsquo;text&amp;rsquo;字段建立映射。
&amp;lsquo;index&amp;rsquo;设置为analyzed说明要先通过分析器，&amp;lsquo;analyzer&amp;rsquo;设置分析器为ik分词的智能粒度切分，默认为standard，不适合中文分词;&amp;lsquo;similarity&amp;rsquo;设置了相似度算法为BM25，默认为向量空间算法。
具体可以看文档。
查询 查询可以通过ID来检索，但是作为一个搜索引擎，ElasticSearch提供了一种基于JSON的DSL查询格式。
search_body = { &amp;#34;query&amp;#34;: { &amp;#34;multi_match&amp;#34;: { &amp;#34;query&amp;#34;: &amp;#34;Hello世界&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;cross_fields&amp;#34;, &amp;#34;operator&amp;#34;: &amp;#34;or&amp;#34;, &amp;#34;fields&amp;#34;: [ &amp;#34;author&amp;#34;, &amp;#34;text^2&amp;#34; ] } }, &amp;#39;highlight&amp;#39;:{ &amp;#39;fields&amp;#39;:{ &amp;#39;author&amp;#39;:{}, &amp;#39;text&amp;#39;:{} } } } res = es.search(index=&amp;#39;test-index&amp;#39;, doc_type=&amp;#39;tweet&amp;#39;, body=search_body) Query 上面的示例中使用了multi match query来进行多字段查询，multi match query对fields中的每个field进行query查询。
&amp;lsquo;operator&amp;rsquo;定义了对查询结果进行的操作，&amp;lsquo;or&amp;rsquo;代表取并集。</description>
    </item>
    
    <item>
      <title>程序员修炼之道</title>
      <link>https://dailydreamer.me/posts/2015-06-04-a-pragmatic-programmer/</link>
      <pubDate>Thu, 04 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2015-06-04-a-pragmatic-programmer/</guid>
      <description>这本书出版有些年头了，虽然其中的例子有些老旧，但是有些思想和哲学永远不会过时。
注重实效的哲学 负责，提供各种选择，不找蹩脚的借口。
避免软件腐烂，破窗效应，不要容忍破窗户。
启动杂役，做变化的催化剂。
不要被温水煮青蛙，留意大图景。
让用户参与权衡，使质量成为需求问题。
像管理金融资产一样管理知识资产。定期为你的知识资产投资。
不要搁置问题。
批判的分析你读到的和听到的。
注重交流，想清楚你要说什么，了解听众。
注重实效的途径 重复的危害 系统中的每一项知识都必须具有单一、无歧义、权威的表示。Don&amp;rsquo;t Repeat Yourself！这不是你是否能记住的问题，而是何时忘记的问题。
强加的重复：
客户端服务器端不同语言：可以根据元数据在Build时生成不同语言的类定义及结构。
根据需求文档自动生成测试。
无意的重复：
需要缓存时可能会破坏DRY原则，但是应该在类内部解决，不要将其暴露给外界。
正交性 消除无关事物之间的影响。
可撤销性 不存在最终决策，采用灵活的架构。
曳光弹 用曳光弹找到目标，给出可展示的项目骨架，它可以即时的反馈。
原型与便笺 为了学习而制作原型。原型甚至可以不用编码，他需要确定各个组件的责任和是否解耦。
基本工具 用纯文本保存知识。它不会过时，更易测试。
要修正问题，而不是发出指责。
再现bug，使数据可视化。
向别人讲述你的代码要做什么时可能会帮助你理清思路。
不要假定，要证明。
注重实效的偏执 你不可能写出完美的软件。
DBC 按合约设计 前条件，后条件，类不变项。
死程序不说谎 早崩溃，要崩溃不要破坏。
断言式编程 如果他不可能发生，用断言确保。
弯曲，或折断 使模块之间的耦合减至最小。
要配置，不要集成。
将抽象放进代码，将细节放进元数据。
总是为并发进行设计。
使模型与视图分离。
当你编码时 不要靠巧合编程。
为你的假定建立文档。
早重构，常重构。这是一种痛苦管理。经常进行短小的重构之后测试。
测试驱动的设计。测试你的软件，否则你的用户就得测试。
与用户一同工作，以像用户一样思考。
抽象比细节获得更长久。
不要在盒子外面思考，要找到盒子，即真正的约束。亚历山大大帝用剑劈开了弗里吉亚国王戈尔系的号称解不开的结。
有些事情去做胜于描述，比如试着描述一下你系鞋带的过程。不要一开始编写太过详尽的规范。它和编码总是交替进行。
不要做形式方法的奴隶，有时原型展示比UML图更有说服力。昂贵的工具不一定能制作出更好的设计。
注重实效的项目 不要使用手工流程。
早测试，常测试，自动测试。
温和的超出用户的期望。与用户交流期望。
在你的作品上签名。这是责任和荣耀的表现。</description>
    </item>
    
    <item>
      <title>在AWS上配置ElasticSearch</title>
      <link>https://dailydreamer.me/posts/2015-06-02-config-elasticsearch-on-aws/</link>
      <pubDate>Tue, 02 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/posts/2015-06-02-config-elasticsearch-on-aws/</guid>
      <description>最近在AWS EC2上部署了ElasticSearch，感觉AWS的文档详细但稍显凌乱，在这里总结一下步骤。
首先注册AWS。注意你需要一张支持外币支付的信用卡。
然后创建IAM用户，并配置其权限和密钥对。 可按照文档中的步骤来。 注意为了使elasticsearch节点启动后能够自动发现别的节点，你可能需要在这一步为该用户而外设置read-only权限。
之后有两种方案，可以直接部署在EC2上，价格便宜量又足。 也可以部署在EMR上，获得Haddop的集群管理能力，方便扩展以及将来部署其它基于Haddop的程序。但是注意使用EMR除了支付EMR的计费还要支付其使用的EC2及S3等的计费。
部署在EC2上 进入EC2控制面板启动实例。 如果你希望数据在EC2实例关闭后不丢失需要为其配置挂载EBS卷并将其存储至EBS中，详细见文档。
注意EBS卷最好在home/ec2-user/下新建目录挂载，上次我挂载在home/ec2-user/下结果不知道.ssh是存在那里的，然后就连接不上了。。。 挂载完EBS卷后需要更改其权限使得普通用户可以读写文件。 sudo chmod 777 ./ -R
之后为其配置EIP来避免每次重启实例后IP地址改变。 EIP是一个固定的共有IP，将其和一个EC2实例的私有IP绑定即可。 这样也方便切换实例而IP不变。
最后即可ssh连接到EC2上然后安装ElasticSearch了。
安装好ElasticSearch之后还需安装elasticsearch-cloud-aws插件并配置才能实现自动Discovery。 大致的配置如
# AWS discovery cloud.aws.access_key: KEY cloud.aws.secret_key: KEY plugin.mandatory: cloud-aws discovery.type: ec2 discovery.zen.ping.multicast.enabled: false discovery.ec2.groups: &amp;#34;elasticsearch&amp;#34; discovery.ec2.availability_zones: &amp;#34;ap-northeast-1a&amp;#34; cloud.aws.region: &amp;#34;ap-northeast-1&amp;#34; discovery.ec2.host_type: &amp;#34;public_ip&amp;#34; network.publish_host: [PUBLIC_IP] discovery.ec2.ping_timeout: &amp;#34;30s&amp;#34; discovery.ec2.groups是你的EC2集群所在的安全组，注意用这种方式的设置会将必须该安全组中所有节点都启动ElasticSearch服务才行，否则会一直等待。 如果不想这样可以使用Tag设置。
discovery.ec2.availability_zones一定要写对，否则节点会无法互相发现，不知道可以看EC2控制面版中有写。
network.publish_host是该节点的公网IP，可使用绑定的弹性IP。
更加详细的设置可以看这里。
有关部署的更加详细的步骤可以参考这里。
注意如果弹性IP更换了绑定的实例之后要ssh之前需要将原来保存在本地的host_key删除，使用命令ssh-keygen -R hostname,否则会报Host key verification failed。
部署在EMR上 安装AWS CLI。 可按照文档安装并配置。
然后直接使用Amazon EMR的bootstrp action脚本即可。 这个仓库中还有其它基于Hadooop的软件的启动脚本，如spark，cascading等。
输入命令(相关参数可自行配置)</description>
    </item>
    
  </channel>
</rss>
